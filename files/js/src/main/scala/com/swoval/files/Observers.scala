// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.io.IOException
import java.util.{ ArrayList, HashMap, Iterator, List, Map }
import java.util.concurrent.atomic.AtomicInteger

import com.swoval.files.DataViews.Entry

/**
 * Container class that wraps multiple [[FileTreeViews.CacheObserver]] and runs the callbacks
 * for each whenever the [[com.swoval.files.FileCache]] detects an event.
 *
 * @tparam T the data type for the [[com.swoval.files.FileCache]] to which the observers
 *     correspond
 */
class Observers[T] extends FileTreeViews.CacheObserver[T] with AutoCloseable {

  private val counter: AtomicInteger = new AtomicInteger(0)

  private val observers: Map[Integer, FileTreeViews.CacheObserver[T]] =
    new HashMap()

  override def onCreate(newEntry: Entry[T]): Unit = {
    var cbs: List[FileTreeViews.CacheObserver[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[FileTreeViews.CacheObserver[T]] = cbs.iterator()
    while (it.hasNext) it.next().onCreate(newEntry)
  }

  override def onDelete(oldEntry: Entry[T]): Unit = {
    var cbs: List[FileTreeViews.CacheObserver[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[FileTreeViews.CacheObserver[T]] = cbs.iterator()
    while (it.hasNext) it.next().onDelete(oldEntry)
  }

  override def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit = {
    var cbs: List[FileTreeViews.CacheObserver[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[FileTreeViews.CacheObserver[T]] = cbs.iterator()
    while (it.hasNext) it.next().onUpdate(oldEntry, newEntry)
  }

  override def onError(exception: IOException): Unit = {
    var cbs: List[FileTreeViews.CacheObserver[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[FileTreeViews.CacheObserver[T]] = cbs.iterator()
    while (it.hasNext) it.next().onError(exception)
  }

  /**
   * Add an cacheObserver to receive events.
   *
   * @param cacheObserver the new cacheObserver
   * @return a handle to the added cacheObserver that can be used to halt observation using [[    com.swoval.files.Observers.removeObserver]] .
   */
  def addObserver(cacheObserver: FileTreeViews.CacheObserver[T]): Int = {
    val key: Int = counter.getAndIncrement
    observers.synchronized {
      observers.put(key, cacheObserver)
    }
    key
  }

  /**
   * Remove an instance of [[FileTreeViews.CacheObserver]] that was previously added using
   * [[com.swoval.files.Observers.addObserver]].
   *
   * @param handle the handle to remove
   */
  def removeObserver(handle: Int): Unit = {
    observers.synchronized {
      observers.remove(handle)
    }
  }

  override def close(): Unit = {
    observers.clear()
  }

}
