// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.PathWatchers.Event.Kind.Create
import com.swoval.files.PathWatchers.Event.Kind.Delete
import com.swoval.files.PathWatchers.Event.Kind.Error
import com.swoval.files.PathWatchers.Event.Kind.Modify
import com.swoval.functional.Filters.AllPass
import com.swoval.files.Executor.ThreadHandle
import com.swoval.files.FileTreeDataViews.Converter
import com.swoval.files.FileTreeDataViews.Entry
import com.swoval.files.FileTreeRepositoryImpl.Callback
import com.swoval.files.FileTreeViews.CacheObserver
import com.swoval.files.FileTreeViews.ObservableCache
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.files.PathWatchers.Event.Kind
import com.swoval.functional.Consumer
import com.swoval.functional.Filter
import java.io.IOException
import java.nio.file.NoSuchFileException
import java.nio.file.NotDirectoryException
import java.nio.file.Path
import java.util.ArrayList
import java.util.Collections
import java.util.Comparator
import java.util.HashMap
import java.util.HashSet
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Set

class FileCacheDirectoryTree[T <: AnyRef](private val converter: Converter[T],
                                          private val callbackExecutor: Executor,
                                          internalExecutor: Executor,
                                          val symlinkWatcher: SymlinkWatcher)
    extends ObservableCache[T]
    with FileTreeDataView[T] {

  private val directories: Map[Path, CachedDirectory[T]] = new HashMap()

  private val directoryRegistry: DirectoryRegistry =
    new DirectoryRegistryImpl()

  private val pendingFiles: Set[Path] = new HashSet()

  private val observers: CacheObservers[T] = new CacheObservers()

  private val followLinks: Boolean = true

  symlinkWatcher.addObserver(new Observer[Event]() {
    override def onError(t: Throwable): Unit = {
      t.printStackTrace(System.err)
    }

    override def onNext(event: Event): Unit = {
      internalExecutor.run(new Consumer[ThreadHandle]() {
        override def accept(threadHandle: ThreadHandle): Unit = {
          handleEvent(event, threadHandle)
        }
      })
    }
  })

  private val READ_ONLY_DIRECTORY_REGISTRY: DirectoryRegistry =
    new DirectoryRegistry() {
      override def close(): Unit = {}

      override def addDirectory(path: Path, maxDepth: Int): Boolean = false

      override def maxDepthFor(path: Path): Int =
        directoryRegistry.maxDepthFor(path)

      override def registered(): List[Path] = directoryRegistry.registered()

      override def removeDirectory(path: Path): Unit = {}

      override def acceptPrefix(path: Path): Boolean =
        directoryRegistry.acceptPrefix(path)

      override def accept(path: Path): Boolean = directoryRegistry.accept(path)
    }

  def readOnlyDirectoryRegistry(): DirectoryRegistry =
    READ_ONLY_DIRECTORY_REGISTRY

  def unregister(path: Path, threadHandle: ThreadHandle): Unit = {
    directoryRegistry.removeDirectory(path)
    if (!directoryRegistry.accept(path)) {
      val dir: CachedDirectory[T] = find(path)
      if (dir != null) {
        if (dir.getPath == path) {
          directories.remove(path)
        } else {
          dir.remove(path, threadHandle)
        }
      }
    }
  }

  private def find(path: Path): CachedDirectory[T] = {
    var foundDir: CachedDirectory[T] = null
    val it: Iterator[CachedDirectory[T]] = directories.values.iterator()
    while (it.hasNext) {
      val dir: CachedDirectory[T] = it.next()
      if (path.startsWith(dir.getPath) &&
          (foundDir == null || dir.getPath.startsWith(foundDir.getPath))) {
        foundDir = dir
      }
    }
    foundDir
  }

  private def runCallbacks(callbacks: List[Callback]): Unit = {
    if (!callbacks.isEmpty) {
      callbackExecutor.run(new Consumer[ThreadHandle]() {
        override def accept(threadHandle: ThreadHandle): Unit = {
          Collections.sort(callbacks)
          val it: Iterator[Callback] = callbacks.iterator()
          while (it.hasNext) it.next().run()
        }
      })
    }
  }

  def handleEvent(typedPath: TypedPath, threadHandle: ThreadHandle): Unit = {
    val path: Path = typedPath.getPath
    val callbacks: List[Callback] = new ArrayList[Callback]()
    if (typedPath.exists()) {
      val dir: CachedDirectory[T] = find(typedPath.getPath)
      if (dir != null) {
        dir
          .update(typedPath, threadHandle)
          .observe(callbackObserver(callbacks, threadHandle))
      } else if (pendingFiles.remove(path)) {
        try {
          var cachedDirectory: CachedDirectory[T] = null
          try cachedDirectory = FileTreeViews
            .cached[T](path, converter, directoryRegistry.maxDepthFor(path), followLinks)
          catch {
            case nde: NotDirectoryException =>
              cachedDirectory = FileTreeViews.cached[T](path, converter, -1, followLinks)

          }
          val previous: CachedDirectory[T] =
            directories.put(path, cachedDirectory)
          if (previous != null) previous.close()
          addCallback(callbacks,
                      typedPath,
                      null,
                      cachedDirectory.getEntry,
                      Create,
                      null,
                      threadHandle)
          val it: Iterator[FileTreeDataViews.Entry[T]] = cachedDirectory
            .listEntries(cachedDirectory.getMaxDepth, AllPass)
            .iterator()
          while (it.hasNext) {
            val entry: FileTreeDataViews.Entry[T] = it.next()
            addCallback(callbacks, entry, null, entry, Create, null, threadHandle)
          }
        } catch {
          case e: IOException => pendingFiles.add(path)

        }
      }
    } else {
      val removeIterators: List[Iterator[FileTreeDataViews.Entry[T]]] =
        new ArrayList[Iterator[FileTreeDataViews.Entry[T]]]()
      val directoryIterator: Iterator[CachedDirectory[T]] =
        new ArrayList(directories.values).iterator()
      while (directoryIterator.hasNext) {
        val dir: CachedDirectory[T] = directoryIterator.next()
        if (path.startsWith(dir.getPath)) {
          val updates: List[FileTreeDataViews.Entry[T]] =
            dir.remove(path, threadHandle)
          val it: Iterator[Path] = directoryRegistry.registered().iterator()
          while (it.hasNext) if (it.next() == path) {
            pendingFiles.add(path)
          }
          if (dir.getPath == path) {
            directories.remove(path)
            updates.add(dir.getEntry)
          }
          removeIterators.add(updates.iterator())
        }
      }
      val it: Iterator[Iterator[FileTreeDataViews.Entry[T]]] =
        removeIterators.iterator()
      while (it.hasNext) {
        val removeIterator: Iterator[FileTreeDataViews.Entry[T]] = it.next()
        while (removeIterator.hasNext) {
          val entry: FileTreeDataViews.Entry[T] =
            Entries.setExists(removeIterator.next(), false)
          addCallback(callbacks, entry, entry, null, Delete, null, threadHandle)
        }
      }
    }
    runCallbacks(callbacks)
  }

  def close(): Unit = {
    throw new UnsupportedOperationException("close")
  }

  def close(threadHandle: ThreadHandle): Unit = {
    callbackExecutor.close()
    if (symlinkWatcher != null) symlinkWatcher.close()
    val directoryIterator: Iterator[CachedDirectory[T]] =
      directories.values.iterator()
    while (directoryIterator.hasNext) directoryIterator.next().close()
    observers.close()
    directories.clear()
    directoryRegistry.close()
    pendingFiles.clear()
  }

  def register(path: Path,
               maxDepth: Int,
               watcher: PathWatcher[PathWatchers.Event],
               threadHandle: ThreadHandle): CachedDirectory[T] =
    if (directoryRegistry.addDirectory(path, maxDepth)) {
      watcher.register(path, maxDepth)
      val dirs: List[CachedDirectory[T]] =
        new ArrayList[CachedDirectory[T]](directories.values)
      Collections.sort(
        dirs,
        new Comparator[CachedDirectory[T]]() {
          override def compare(left: CachedDirectory[T], right: CachedDirectory[T]): Int =
            left.getPath.compareTo(right.getPath)
        }
      )
      val it: Iterator[CachedDirectory[T]] = dirs.iterator()
      var existing: CachedDirectory[T] = null
      while (it.hasNext && existing == null) {
        val dir: CachedDirectory[T] = it.next()
        if (path.startsWith(dir.getPath)) {
          val depth: Int =
            if (path == dir.getPath) 0
            else (dir.getPath.relativize(path).getNameCount - 1)
          if (dir.getMaxDepth == java.lang.Integer.MAX_VALUE || maxDepth < dir.getMaxDepth - depth) {
            existing = dir
          } else if (depth <= dir.getMaxDepth) {
            dir.close()
            try {
              val md: Int =
                if (maxDepth < java.lang.Integer.MAX_VALUE - depth - 1)
                  maxDepth + depth + 1
                else java.lang.Integer.MAX_VALUE
              existing = FileTreeViews
                .cached[T](dir.getPath, converter, md, followLinks)
              directories.put(dir.getPath, existing)
            } catch {
              case e: IOException => existing = null

            }
          }
        }
      }
      var dir: CachedDirectory[T] = null
      if (existing == null) {
        try {
          try dir = FileTreeViews.cached[T](path, converter, maxDepth, followLinks)
          catch {
            case e: NotDirectoryException =>
              dir = FileTreeViews.cached[T](path, converter, -1, followLinks)

          }
          directories.put(path, dir)
        } catch {
          case e: NoSuchFileException => {
            pendingFiles.add(path)
            dir = FileTreeViews.cached[T](path, converter, -1, followLinks)
          }

        }
      } else {
        existing.update(TypedPaths.get(path), threadHandle)
        dir = existing
      }
      dir
    } else {
      null
    }

  private def addCallback(callbacks: List[Callback],
                          typedPath: TypedPath,
                          oldEntry: FileTreeDataViews.Entry[T],
                          newEntry: FileTreeDataViews.Entry[T],
                          kind: Kind,
                          ioException: IOException,
                          threadHandle: ThreadHandle): Unit = {
    if (typedPath.isSymbolicLink) {
      val path: Path = typedPath.getPath
      if (typedPath.exists()) {
        symlinkWatcher.addSymlink(path, directoryRegistry.maxDepthFor(path), threadHandle)
      } else {
        try symlinkWatcher.remove(path)
        catch {
          case e: InterruptedException => {}

        }
      }
    }
    callbacks.add(new Callback(typedPath, kind) {
      override def run(): Unit = {
        try if (ioException != null) {
          observers.onError(ioException)
        } else if (kind == Create) {
          observers.onCreate(newEntry)
        } else if (kind == Delete) {
          observers.onDelete(Entries.setExists(oldEntry, false))
        } else if (kind == Modify) {
          observers.onUpdate(oldEntry, newEntry)
        } catch {
          case e: Exception => e.printStackTrace()

        }
      }
    })
  }

  override def addObserver(observer: Observer[Entry[T]]): Int =
    observers.addObserver(observer)

  override def removeObserver(handle: Int): Unit = {
    observers.removeObserver(handle)
  }

  override def addCacheObserver(observer: CacheObserver[T]): Int =
    observers.addCacheObserver(observer)

  override def listEntries(path: Path,
                           maxDepth: Int,
                           filter: Filter[_ >: Entry[T]]): List[Entry[T]] = {
    val dir: CachedDirectory[T] = find(path)
    if (dir == null) {
      new ArrayList()
    } else {
      if (dir.getPath == path && dir.getMaxDepth == -1) {
        val result: List[FileTreeDataViews.Entry[T]] =
          new ArrayList[FileTreeDataViews.Entry[T]]()
        result.add(dir.getEntry)
        result
      } else {
        dir.listEntries(path, maxDepth, filter)
      }
    }
  }

  private def callbackObserver(callbacks: List[Callback],
                               threadHandle: ThreadHandle): FileTreeViews.CacheObserver[T] =
    new FileTreeViews.CacheObserver[T]() {
      override def onCreate(newEntry: FileTreeDataViews.Entry[T]): Unit = {
        addCallback(callbacks, newEntry, null, newEntry, Create, null, threadHandle)
      }

      override def onDelete(oldEntry: FileTreeDataViews.Entry[T]): Unit = {
        addCallback(callbacks, oldEntry, oldEntry, null, Delete, null, threadHandle)
      }

      override def onUpdate(oldEntry: FileTreeDataViews.Entry[T],
                            newEntry: FileTreeDataViews.Entry[T]): Unit = {
        addCallback(callbacks, oldEntry, oldEntry, newEntry, Modify, null, threadHandle)
      }

      override def onError(exception: IOException): Unit = {
        addCallback(callbacks, null, null, null, Error, exception, threadHandle)
      }
    }

  override def list(path: Path, maxDepth: Int, filter: Filter[_ >: TypedPath]): List[TypedPath] = {
    val dir: CachedDirectory[T] = find(path)
    if (dir == null) {
      new ArrayList()
    } else {
      if (dir.getPath == path && dir.getMaxDepth == -1) {
        val result: List[TypedPath] = new ArrayList[TypedPath]()
        result.add(TypedPaths.getDelegate(dir.getPath, dir.getEntry))
        result
      } else {
        dir.list(path, maxDepth, filter)
      }
    }
  }

}
