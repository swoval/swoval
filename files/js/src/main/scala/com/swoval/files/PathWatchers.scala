// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.functional.Consumer
import com.swoval.runtime.Platform
import java.io.IOException
import java.nio.file.Path
import scala.beans.{ BeanProperty, BooleanBeanProperty }

object PathWatchers {

  /**
   * Create a PathWatcher for the runtime platform.
   *
   * @return PathWatcher for the runtime platform
   *     initialized
   */
  def get(): PathWatcher[PathWatchers.Event] =
    get(Executor.make("com.swoval.files.PathWatcher-internal-executor"),
        new DirectoryRegistryImpl())

  /**
   * Create a PathWatcher for the runtime platform.
   *
   * @param executor provides a single threaded context to manage state
   * @param registry The registry of directories to monitor
   * @return PathWatcher for the runtime platform
   *     initialized
   */
  def get(executor: Executor, registry: DirectoryRegistry): PathWatcher[Event] =
    if (Platform.isMac) ApplePathWatchers.get(executor, registry)
    else PlatformWatcher.make(executor, registry)

  /**
   * Create a PathWatcher for the runtime platform.
   *
   * @param callback [[Consumer]] to run on file events
   * @param executor provides a single threaded context to manage state
   * @param registry The registry of directories to monitor
   * @return PathWatcher for the runtime platform
   */
  def get(service: RegisterableWatchService,
          executor: Executor,
          registry: DirectoryRegistry): PathWatcher[Event] =
    PlatformWatcher.make(service, executor, registry)

  class Overflow(@BeanProperty val path: Path)

  object Event {

    object Kind {

      /**
 A new file was created.
       */
      val Create: Kind = new Kind("Create", 1)

      /**
 The file was deleted.
       */
      val Delete: Kind = new Kind("Delete", 2)

      /**
 An error occurred processing the event.
       */
      val Error: Kind = new Kind("Error", 4)

      /**
 An existing file was modified.
       */
      val Modify: Kind = new Kind("Modify", 3)

    }

    /**
     * An enum like class to indicate the type of file event. It isn't an actual enum because the
     * scala.js codegen has problems with enum types.
     */
    class Kind(private val name: String, private val priority: Int) extends Comparable[Kind] {

      override def toString(): String = name

      override def equals(other: Any): Boolean = other match {
        case other: Kind => other.name == this.name
        case _           => false

      }

      override def hashCode(): Int = name.hashCode

      override def compareTo(that: Kind): Int =
        java.lang.Integer.compare(this.priority, that.priority)

    }

  }

  /**
 Container for [[PathWatcher]] events.
   */
  class Event(path: TypedPath, @BeanProperty val kind: Event.Kind) extends TypedPath {

    private val typedPath: TypedPath = path

    /**
     * Returns the path that triggered the event.
     *
     * @return the path that triggered the event.
     */
    def getPath(): Path = typedPath.getPath

    override def exists(): Boolean = typedPath.exists()

    override def isDirectory(): Boolean = typedPath.isDirectory

    override def isFile(): Boolean = typedPath.isFile

    override def isSymbolicLink(): Boolean = typedPath.isSymbolicLink

    override def toRealPath(): Path = typedPath.toRealPath()

    override def equals(other: Any): Boolean = other match {
      case other: Event => {
        val that: Event = other
        this.typedPath == that.typedPath && this.kind == that.kind
      }
      case _ => false

    }

    override def hashCode(): Int = typedPath.hashCode ^ kind.hashCode

    override def toString(): String =
      "Event(" + typedPath.getPath + ", " + kind + ")"

    override def compareTo(that: TypedPath): Int =
      this.getPath.compareTo(that.getPath)

  }

}
