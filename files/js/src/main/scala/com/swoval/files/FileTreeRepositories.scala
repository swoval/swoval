// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.FileTreeDataViews.Converter
import com.swoval.files.FileTreeDataViews.OnError
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.functional.Consumer
import java.io.IOException

object FileTreeRepositories {

  /**
   * Create a file cache with a CacheObserver of events.
   *
   * @param converter converts a path to the cached value type T
   * @tparam T the value type of the cache entries
   * @return a file cache.
   */
  def get[T <: AnyRef](converter: Converter[T]): FileTreeRepository[T] = {
    val executor: Executor =
      Executor.make("FileTreeRepository-internal-executor")
    val copy: Executor = executor.copy()
    val symlinkWatcher: SymlinkWatcher =
      new SymlinkWatcher(PathWatchers.get(copy, new DirectoryRegistryImpl()), new OnError() {
        override def apply(exception: IOException): Unit = {}
      }, copy)
    val tree: FileCacheDirectoryTree[T] = new FileCacheDirectoryTree[T](
      converter,
      Executor.make("FileTreeRepository-callback-executor"),
      copy,
      symlinkWatcher)
    val pathWatcher: PathWatcher[PathWatchers.Event] =
      PathWatchers.get(copy, tree.readOnlyDirectoryRegistry())
    pathWatcher.addObserver(new Observer[Event]() {
      override def onError(t: Throwable): Unit = {}

      override def onNext(event: Event): Unit = {
        copy.run(new Consumer[Executor.Thread]() {
          override def accept(thread: Executor.Thread): Unit = {
            tree.handleEvent(event, thread)
          }
        })
      }
    })
    val watcher: FileCachePathWatcher[T] =
      new FileCachePathWatcher[T](tree, pathWatcher)
    new FileTreeRepositoryImpl(tree, watcher, executor)
  }

}
