// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.io.IOException
import java.nio.file.{ Path, Paths }
import java.util.{ ArrayList, HashMap, Iterator, List, Map }
import java.util.Map.Entry
import java.util.concurrent.Callable
import java.util.concurrent.atomic.AtomicBoolean

import com.swoval.files.ApplePathWatcher._
import com.swoval.files.PathWatchers.Event
import com.swoval.files.PathWatchers.Event.Kind.{ Create, Delete, Modify, Overflow }
import com.swoval.files.apple.FileEventsApi.ClosedFileEventsApiException
import com.swoval.files.apple.{ FileEvent, FileEventsApi, Flags }
import com.swoval.functional.{ Consumer, Either }
import com.swoval.functional.Either.leftProjection

object ApplePathWatcher {

  private val DefaultOnStreamRemoved: DefaultOnStreamRemoved =
    new DefaultOnStreamRemoved()

  private class Stream(val id: Int)

  /**
 A no-op callback to invoke when streams are removed.
   */
  class DefaultOnStreamRemoved() extends Consumer[String] {

    override def accept(stream: String): Unit = {}

  }

}

/**
 * Implements the PathWatcher for Mac OSX using the [[https://developer.apple.com/library/content/documentation/Darwin/Conceptual/FSEvents_ProgGuide/UsingtheFSEventsFramework/UsingtheFSEventsFramework.html Apple File System Events Api]]
 */
class ApplePathWatcher(private val latency: Double,
                       private val flags: Flags.Create,
                       onFileEvent: Consumer[Event],
                       onStreamRemoved: Consumer[String],
                       executor: Executor,
                       managedDirectoryRegistry: DirectoryRegistry)
    extends PathWatcher {

  private val directoryRegistry: DirectoryRegistry =
    if (managedDirectoryRegistry == null) new DirectoryRegistry()
    else managedDirectoryRegistry

  private val streams: Map[Path, Stream] = new HashMap()

  private val closed: AtomicBoolean = new AtomicBoolean(false)

  private val internalExecutor: Executor =
    if (executor == null)
      Executor.make("com.swoval.files.ApplePathWatcher-internalExecutor")
    else executor

  private val fileEventsApi: FileEventsApi = FileEventsApi.apply(
    new Consumer[FileEvent]() {
      override def accept(fileEvent: FileEvent): Unit = {
        internalExecutor.run(new Runnable() {
          override def run(): Unit = {
            val fileName: String = fileEvent.fileName
            val path: TypedPath = TypedPaths.get(Paths.get(fileName))
            if (directoryRegistry.accept(path.getPath)) {
              var event: Event = null
              event =
                if (fileEvent.mustScanSubDirs()) new Event(path, Overflow)
                else if (fileEvent.itemIsFile())
                  if (fileEvent.isNewFile && path.exists())
                    new Event(path, Create)
                  else if (fileEvent.isRemoved || !path.exists())
                    new Event(path, Delete)
                  else new Event(path, Modify)
                else if (path.exists()) new Event(path, Modify)
                else new Event(path, Delete)
              onFileEvent.accept(event)
            }
          }
        })
      }
    },
    new Consumer[String]() {
      override def accept(stream: String): Unit = {
        internalExecutor.block(new Runnable() {
          override def run(): Unit = {
            new Runnable() {
              override def run(): Unit = {
                streams.remove(Paths.get(stream))
              }
            }.run()
          }
        })
        onStreamRemoved.accept(stream)
      }
    }
  )

  /**
   * Registers a path
   *
   * @param path The directory to watch for file events
   * @param maxDepth The maximum number of subdirectory levels to visit
   * @return an [[com.swoval.functional.Either]] containing the result of the registration or an
   *     IOException if registration fails. This method should be idempotent and return true the
   *     first time the directory is registered or when the depth is changed. Otherwise it should
   *     return false.
   */
  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] =
    register(path, flags, maxDepth)

  /**
   * Registers with additional flags
   *
   * @param path The directory to watch for file events
   * @param flags The flags [[com.swoval.files.apple.Flags.Create]] to set for the directory
   * @param maxDepth The maximum number of subdirectory levels to visit
   * @return an [[com.swoval.functional.Either]] containing the result of the registration or an
   *     IOException if registration fails. This method should be idempotent and return true the
   *     first time the directory is registered or when the depth is changed. Otherwise it should
   *     return false.
   */
  def register(path: Path, flags: Flags.Create, maxDepth: Int): Either[IOException, Boolean] = {
    val either: Either[Exception, Boolean] =
      internalExecutor.block(new Callable[Boolean]() {
        override def call(): Boolean =
          registerImpl(path, flags, maxDepth)
      })
    if (either.isLeft &&
        !(leftProjection(either).getValue.isInstanceOf[IOException])) {
      throw new RuntimeException(leftProjection(either).getValue)
    }
    either.castLeft(classOf[IOException])
  }

  private def registerImpl(path: Path, flags: Flags.Create, maxDepth: Int): Boolean = {
    var result: Boolean = true
    var realPath: Path = path
    try realPath = path.toRealPath()
    catch {
      case e: IOException => {}

    }
    val entry: Entry[Path, Stream] = find(realPath)
    directoryRegistry.addDirectory(path, maxDepth)
    if (entry == null) {
      try {
        val id: Int = fileEventsApi.createStream(realPath.toString, latency, flags.getValue)
        if (id == -1) {
          result = false
          System.err.println("Error watching " + realPath + ".")
        } else {
          removeRedundantStreams(realPath)
          streams.put(realPath, new Stream(id))
        }
      } catch {
        case e: ClosedFileEventsApiException => {
          close()
          result = false
        }

      }
    }
    result
  }

  private def removeRedundantStreams(path: Path): Unit = {
    val toRemove: List[Path] = new ArrayList[Path]()
    val it: Iterator[Entry[Path, Stream]] = streams.entrySet().iterator()
    while (it.hasNext) {
      val e: Entry[Path, Stream] = it.next()
      val key: Path = e.getKey
      if (key.startsWith(path) && key != path) {
        toRemove.add(key)
      }
    }
    val pathIterator: Iterator[Path] = toRemove.iterator()
    while (pathIterator.hasNext) unregisterImpl(pathIterator.next())
  }

  private def unregisterImpl(path: Path): Unit = {
    if (!closed.get) {
      directoryRegistry.removeDirectory(path)
      val stream: Stream = streams.remove(path)
      if (stream != null && stream.id != -1) {
        fileEventsApi.stopStream(stream.id)
      }
    }
  }

  /**
   * Unregisters a path
   *
   * @param path The directory to remove from monitoring
   */
  override def unregister(path: Path): Unit = {
    internalExecutor.block(new Runnable() {
      override def run(): Unit = {
        unregisterImpl(path)
      }
    })
  }

  /**
 Closes the FileEventsApi and shuts down the {@code internalExecutor}.
   */
  override def close(): Unit = {
    if (closed.compareAndSet(false, true)) {
      internalExecutor.block(new Runnable() {
        override def run(): Unit = {
          streams.clear()
          fileEventsApi.close()
        }
      })
      internalExecutor.close()
    }
  }

  def this(onFileEvent: Consumer[Event], executor: Executor, directoryRegistry: DirectoryRegistry) =
    this(0.01,
         new Flags.Create().setNoDefer().setFileEvents(),
         onFileEvent,
         DefaultOnStreamRemoved,
         executor,
         directoryRegistry)

  private def find(path: Path): Entry[Path, Stream] = {
    val it: Iterator[Entry[Path, Stream]] = streams.entrySet().iterator()
    var result: Entry[Path, Stream] = null
    while (result == null && it.hasNext) {
      val entry: Entry[Path, Stream] = it.next()
      if (path.startsWith(entry.getKey)) {
        result = entry
      }
    }
    result
  }

}
