// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.Executor.ThreadHandle
import com.swoval.files.FileTreeDataViews.Entry
import com.swoval.files.FileTreeViews.CacheObserver
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event.Kind
import com.swoval.functional.Either
import com.swoval.functional.Filter
import com.swoval.runtime.ShutdownHooks
import java.io.IOException
import java.nio.file.Path
import java.util.ArrayList
import java.util.List
import java.util.concurrent.atomic.AtomicBoolean
import FileTreeRepositoryImpl._

object FileTreeRepositoryImpl {

  abstract class Callback(private val typedPath: TypedPath, private val kind: Kind)
      extends Runnable
      with Comparable[Callback] {

    override def compareTo(that: Callback): Int = {
      val kindComparision: Int = this.kind.compareTo(that.kind)
      if (kindComparision == 0) this.typedPath.compareTo(that.typedPath)
      else kindComparision
    }

  }

}

class FileTreeRepositoryImpl[T <: AnyRef](private val directoryTree: FileCacheDirectoryTree[T],
                                          private val watcher: FileCachePathWatcher[T],
                                          executor: Executor)
    extends FileTreeRepository[T] {

  private val closed: AtomicBoolean = new AtomicBoolean(false)

  private val internalExecutor: Executor = executor

  private val closeRunnable: Runnable = new Runnable() {
    override def run(): Unit = {
      if (closed.compareAndSet(false, true)) {
        try {
          val threadHandle: ThreadHandle = internalExecutor.getThreadHandle
          try {
            ShutdownHooks.removeHook(shutdownHookId)
            watcher.close(threadHandle)
            directoryTree.close(threadHandle)
          } finally threadHandle.release()
        } catch {
          case e: InterruptedException => {}

        }
        internalExecutor.close()
      }
    }
  }

  private val shutdownHookId: Int = ShutdownHooks.addHook(1, closeRunnable)

  assert((executor != null))

  /**
 Cleans up the path watcher and clears the directory cache.
   */
  override def close(): Unit = {
    closeRunnable.run()
  }

  override def addObserver(observer: Observer[FileTreeDataViews.Entry[T]]): Int =
    addCacheObserver(new CacheObserver[T]() {
      override def onCreate(newEntry: Entry[T]): Unit = {
        observer.onNext(newEntry)
      }

      override def onDelete(oldEntry: Entry[T]): Unit = {
        observer.onNext(oldEntry)
      }

      override def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit = {
        observer.onNext(newEntry)
      }

      override def onError(exception: IOException): Unit = {
        observer.onError(exception)
      }
    })

  override def removeObserver(handle: Int): Unit = {
    directoryTree.removeObserver(handle)
  }

  override def listEntries(
      path: Path,
      maxDepth: Int,
      filter: Filter[_ >: FileTreeDataViews.Entry[T]]): List[FileTreeDataViews.Entry[T]] =
    try {
      val threadHandle: ThreadHandle = internalExecutor.getThreadHandle
      try directoryTree.listEntries(path, maxDepth, filter)
      finally threadHandle.release()
    } catch {
      case e: InterruptedException => new ArrayList()

    }

  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] =
    try {
      val threadHandle: ThreadHandle = internalExecutor.getThreadHandle
      try Either.right(watcher.register(path, maxDepth, threadHandle))
      catch {
        case e: IOException => Either.left(e)

      } finally threadHandle.release()
    } catch {
      case e: InterruptedException => Either.right(false)

    }

  override def unregister(path: Path): Unit = {
    try {
      val threadHandle: ThreadHandle = internalExecutor.getThreadHandle
      try watcher.unregister(path, threadHandle)
      finally threadHandle.release()
    } catch {
      case e: InterruptedException => {}

    }
  }

  override def list(path: Path, maxDepth: Int, filter: Filter[_ >: TypedPath]): List[TypedPath] =
    directoryTree.list(path, maxDepth, filter)

  override def addCacheObserver(observer: CacheObserver[T]): Int =
    directoryTree.addCacheObserver(observer)

}
