// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.functional.Either.getOrElse
import com.swoval.functional.Either.leftProjection
import java.util.Map.Entry
import com.swoval.files.FileTreeDataViews.OnError
import com.swoval.files.FileTreeViews.Observable
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.functional.Consumer
import com.swoval.functional.Either
import java.io.IOException
import java.nio.file.FileSystemLoopException
import java.nio.file.Files
import java.nio.file.Path
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Set
import java.util.concurrent.atomic.AtomicBoolean
import SymlinkWatcher._

object SymlinkWatcher {

  private class RegisteredPath(val path: Path, base: Path) {

    val paths: Set[Path] = new HashSet()

    paths.add(base)

  }

}

/**
 * Monitors symlink targets. The [[SymlinkWatcher]] maintains a mapping of symlink targets to
 * symlink. When the symlink target is modified, the watcher will detect the update and invoke a
 * provided [[com.swoval.functional.Consumer]] for the symlink.
 */
class SymlinkWatcher(private val watcher: PathWatcher[PathWatchers.Event],
                     private val onError: OnError,
                     private val internalExecutor: Executor)
    extends Observable[Event]
    with AutoCloseable {

  private val isClosed: AtomicBoolean = new AtomicBoolean(false)

  private val watchedSymlinksByDirectory: Map[Path, RegisteredPath] =
    new HashMap()

  private val watchedSymlinksByTarget: Map[Path, RegisteredPath] =
    new HashMap()

  private val observers: Observers[Event] = new Observers()

  override def addObserver(observer: Observer[Event]): Int =
    observers.addObserver(observer)

  override def removeObserver(handle: Int): Unit = {
    removeObserver(handle)
  }

  private def find(path: Path, map: Map[Path, RegisteredPath]): RegisteredPath = {
    val result: RegisteredPath = map.get(path)
    if (result != null) result
    else if (path == null || path.getNameCount == 0) null
    else {
      val parent: Path = path.getParent
      if (parent == null || parent.getNameCount == 0) null
      else find(parent, map)
    }
  }

  private def hasLoop(path: Path): Boolean = {
    var result: Boolean = false
    val parent: Path = path.getParent
    try {
      val realPath: Path = parent.toRealPath()
      result = parent.startsWith(realPath) && parent != realPath
    } catch {
      case e: IOException => {}

    }
    result
  }

  watcher.addObserver(new Observer[Event]() {
    override def onError(t: Throwable): Unit = {
      if (t.isInstanceOf[IOException])
        SymlinkWatcher.this.onError.apply(t.asInstanceOf[IOException])
    }

    override def onNext(event: Event): Unit = {
      if (!isClosed.get) {
        SymlinkWatcher.this.internalExecutor
          .run(new Consumer[Executor.Thread]() {
            override def accept(thread: Executor.Thread): Unit = {
              val callbacks: List[Runnable] = new ArrayList[Runnable]()
              val path: Path = event.getPath
              val registeredPath: RegisteredPath =
                find(path, watchedSymlinksByTarget)
              if (registeredPath != null) {
                val relativized: Path = registeredPath.path.relativize(path)
                val it: Iterator[Path] = registeredPath.paths.iterator()
                while (it.hasNext) {
                  val rawPath: Path = it.next().resolve(relativized)
                  if (!hasLoop(rawPath)) {
                    callbacks.add(new Runnable() {
                      override def run(): Unit = {
                        observers.onNext(new Event(TypedPaths.get(rawPath), event.getKind))
                      }
                    })
                  }
                }
              }
              if (!Files.exists(event.getPath)) {
                watchedSymlinksByTarget.remove(event.getPath)
                val registeredPath: RegisteredPath =
                  watchedSymlinksByDirectory.get(event.getPath)
                if (registeredPath != null) {
                  registeredPath.paths.remove(event.getPath)
                  if (registeredPath.paths.isEmpty) {
                    watcher.unregister(event.getPath)
                    watchedSymlinksByDirectory.remove(event.getPath)
                  }
                }
              }
              val it: Iterator[Runnable] = callbacks.iterator()
              while (it.hasNext) it.next().run()
            }
          })
      }
    }
  })

  override def close(): Unit = {
    internalExecutor.block(new Consumer[Executor.Thread]() {
      override def accept(thread: Executor.Thread): Unit = {
        if (isClosed.compareAndSet(false, true)) {
          val targetIt: Iterator[RegisteredPath] =
            watchedSymlinksByTarget.values.iterator()
          while (targetIt.hasNext) targetIt.next().paths.clear()
          watchedSymlinksByTarget.clear()
          val dirIt: Iterator[RegisteredPath] =
            watchedSymlinksByDirectory.values.iterator()
          while (dirIt.hasNext) dirIt.next().paths.clear()
          watchedSymlinksByDirectory.clear()
          watcher.close()
        }
      }
    })
    internalExecutor.close()
  }

  /**
   * Start monitoring a symlink. As long as the target exists, this method will check if the parent
   * directory of the target is being monitored. If the parent isn't being registered, we register
   * it with the watch service. We add the target symlink to the set of symlinks watched in the
   * parent directory. We also add the base symlink to the set of watched symlinks for this
   * particular target.
   *
   * @param path The symlink base file.
   */
  def addSymlink(path: Path, maxDepth: Int): Unit = {
    internalExecutor.run(new Consumer[Executor.Thread]() {
      override def toString(): String = "Add symlink " + path

      override def accept(thread: Executor.Thread): Unit = {
        if (!isClosed.get) {
          try {
            val realPath: Path = path.toRealPath()
            if (path.startsWith(realPath) && path != realPath) {
              onError.apply(new FileSystemLoopException(path.toString))
            } else {
              val targetRegistrationPath: RegisteredPath =
                watchedSymlinksByTarget.get(realPath)
              if (targetRegistrationPath == null) {
                val registeredPath: RegisteredPath =
                  watchedSymlinksByDirectory.get(realPath)
                if (registeredPath == null) {
                  val result: Either[IOException, Boolean] =
                    watcher.register(realPath, maxDepth)
                  if (getOrElse(result, false)) {
                    watchedSymlinksByDirectory
                      .put(realPath, new RegisteredPath(path, realPath))
                    watchedSymlinksByTarget
                      .put(realPath, new RegisteredPath(realPath, path))
                  } else if (result.isLeft) {
                    onError.apply(leftProjection(result).getValue)
                  }
                }
              } else {
                targetRegistrationPath.paths.add(path)
              }
            }
          } catch {
            case e: IOException => onError.apply(e)

          }
        }
      }
    })
  }

  /**
   * Removes the symlink from monitoring. If there are no remaining targets in the parent directory,
   * then we remove the parent directory from monitoring.
   *
   * @param path The symlink base to stop monitoring
   */
  def remove(path: Path): Unit = {
    internalExecutor.block(new Consumer[Executor.Thread]() {
      override def accept(thread: Executor.Thread): Unit = {
        if (!isClosed.get) {
          var target: Path = null
          val it: Iterator[Entry[Path, RegisteredPath]] =
            watchedSymlinksByTarget.entrySet().iterator()
          while (it.hasNext && target == null) {
            val entry: Entry[Path, RegisteredPath] = it.next()
            if (entry.getValue.paths.remove(path)) {
              target = entry.getKey
            }
          }
          if (target != null) {
            val targetRegisteredPath: RegisteredPath =
              watchedSymlinksByTarget.get(target)
            if (targetRegisteredPath != null) {
              targetRegisteredPath.paths.remove(path)
              if (targetRegisteredPath.paths.isEmpty) {
                watchedSymlinksByTarget.remove(target)
                val registeredPath: RegisteredPath =
                  watchedSymlinksByDirectory.get(target)
                if (registeredPath != null) {
                  registeredPath.paths.remove(target)
                  if (registeredPath.paths.isEmpty) {
                    watcher.unregister(target)
                    watchedSymlinksByDirectory.remove(target)
                  }
                }
              }
            }
          }
        }
      }
    })
  }

}
