// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.io.IOException
import java.nio.file.{ FileSystemLoopException, Files, Path }
import java.util.Map.Entry
import java.util.{ ArrayList, HashMap, HashSet, Iterator, List, Map, Set }
import java.util.concurrent.atomic.AtomicBoolean

import com.swoval.files.CachedDirectories.OnError
import com.swoval.files.PathWatchers.{ Event, Factory }
import com.swoval.files.SymlinkWatcher._
import com.swoval.functional.{ Consumer, Either }
import com.swoval.functional.Either.{ getOrElse, leftProjection }

object SymlinkWatcher {

  private class RegisteredPath(val path: Path, base: Path) {

    val paths: Set[Path] = new HashSet()

    paths.add(base)

  }

}

/**
 * Monitors symlink targets. The [[SymlinkWatcher]] maintains a mapping of symlink targets to
 * symlink. When the symlink target is modified, the watcher will detect the update and invoke a
 * provided [[com.swoval.functional.Consumer]] for the symlink.
 */
class SymlinkWatcher(handleEvent: Consumer[Path],
                     factory: Factory,
                     private val onError: OnError,
                     executor: Executor)
    extends AutoCloseable {

  private val isClosed: AtomicBoolean = new AtomicBoolean(false)

  private val watchedSymlinksByDirectory: Map[Path, RegisteredPath] =
    new HashMap()

  private val watchedSymlinksByTarget: Map[Path, RegisteredPath] =
    new HashMap()

  private val internalExecutor: Executor =
    if (executor == null)
      Executor.make("com.swoval.files.SymlinkWatcher-callback-internalExecutor")
    else executor

  private def find(path: Path, map: Map[Path, RegisteredPath]): RegisteredPath = {
    val result: RegisteredPath = map.get(path)
    if (result != null) result
    else if (path == null || path.getNameCount == 0) null
    else {
      val parent: Path = path.getParent
      if (parent == null || parent.getNameCount == 0) null
      else find(parent, map)
    }
  }

  private def hasLoop(path: Path): Boolean = {
    var result: Boolean = false
    val parent: Path = path.getParent
    try {
      val realPath: Path = parent.toRealPath()
      result = parent.startsWith(realPath) && parent != realPath
    } catch {
      case e: IOException => {}

    }
    result
  }

  val callback: Consumer[Event] = new Consumer[Event]() {
    override def accept(event: Event): Unit = {
      SymlinkWatcher.this.internalExecutor.run(new Runnable() {
        override def run(): Unit = {
          val callbacks: List[Runnable] = new ArrayList[Runnable]()
          val path: Path = event.getPath
          val registeredPath: RegisteredPath =
            find(path, watchedSymlinksByTarget)
          if (registeredPath != null) {
            val relativized: Path = registeredPath.path.relativize(path)
            val it: Iterator[Path] = registeredPath.paths.iterator()
            while (it.hasNext) {
              val rawPath: Path = it.next().resolve(relativized)
              if (!hasLoop(rawPath)) {
                callbacks.add(new Runnable() {
                  override def run(): Unit = {
                    handleEvent.accept(rawPath)
                  }
                })
              }
            }
          }
          if (!Files.exists(event.getPath)) {
            watchedSymlinksByTarget.remove(event.getPath)
            val registeredPath: RegisteredPath =
              watchedSymlinksByDirectory.get(event.getPath)
            if (registeredPath != null) {
              registeredPath.paths.remove(event.getPath)
              if (registeredPath.paths.isEmpty) {
                watcher.unregister(event.getPath)
                watchedSymlinksByDirectory.remove(event.getPath)
              }
            }
          }
          val it: Iterator[Runnable] = callbacks.iterator()
          while (it.hasNext) it.next().run()
        }
      })
    }
  }

  /*
   * This declaration must go below the constructor for javascript codegen.
   */

  private val watcher: PathWatcher =
    factory.create(callback, internalExecutor.copy(), null)

  override def close(): Unit = {
    internalExecutor.block(new Runnable() {
      override def run(): Unit = {
        if (isClosed.compareAndSet(false, true)) {
          watcher.close()
          watchedSymlinksByTarget.clear()
          watchedSymlinksByDirectory.clear()
        }
      }
    })
  }

  /**
   * Start monitoring a symlink. As long as the target exists, this method will check if the parent
   * directory of the target is being monitored. If the parent isn't being registered, we register
   * it with the watch service. We add the target symlink to the set of symlinks watched in the
   * parent directory. We also add the base symlink to the set of watched symlinks for this
   * particular target.
   *
   * @param path The symlink base file.
   */
  def addSymlink(path: Path, maxDepth: Int): Unit = {
    internalExecutor.run(new Runnable() {
      override def toString(): String = "Add symlink " + path

      override def run(): Unit = {
        if (!isClosed.get) {
          try {
            val realPath: Path = path.toRealPath()
            if (path.startsWith(realPath) && path != realPath) {
              throw new FileSystemLoopException(path.toString)
            }
            val targetRegistrationPath: RegisteredPath =
              watchedSymlinksByTarget.get(realPath)
            if (targetRegistrationPath == null) {
              val registeredPath: RegisteredPath =
                watchedSymlinksByDirectory.get(realPath)
              if (registeredPath == null) {
                val result: Either[IOException, Boolean] =
                  watcher.register(realPath, maxDepth)
                if (getOrElse(result, false)) {
                  watchedSymlinksByDirectory
                    .put(realPath, new RegisteredPath(path, realPath))
                  watchedSymlinksByTarget
                    .put(realPath, new RegisteredPath(realPath, path))
                } else if (result.isLeft) {
                  onError.apply(leftProjection(result).getValue)
                }
              }
            } else if (Files.isDirectory(realPath)) {
              onError.apply(new FileSystemLoopException(path.toString))
            } else {
              targetRegistrationPath.paths.add(path)
            }
          } catch {
            case e: IOException => onError.apply(e)

          }
        }
      }
    })
  }

  /**
   * Removes the symlink from monitoring. If there are no remaining targets in the parent directory,
   * then we remove the parent directory from monitoring.
   *
   * @param path The symlink base to stop monitoring
   */
  def remove(path: Path): Unit = {
    internalExecutor.block(new Runnable() {
      override def run(): Unit = {
        if (!isClosed.get) {
          var target: Path = null
          val it: Iterator[Entry[Path, RegisteredPath]] =
            watchedSymlinksByTarget.entrySet().iterator()
          while (it.hasNext && target == null) {
            val entry: Entry[Path, RegisteredPath] = it.next()
            if (entry.getValue.paths.remove(path)) {
              target = entry.getKey
            }
          }
          if (target != null) {
            val targetRegisteredPath: RegisteredPath =
              watchedSymlinksByTarget.get(target)
            if (targetRegisteredPath != null) {
              targetRegisteredPath.paths.remove(path)
              if (targetRegisteredPath.paths.isEmpty) {
                watchedSymlinksByTarget.remove(target)
                val registeredPath: RegisteredPath =
                  watchedSymlinksByDirectory.get(target)
                if (registeredPath != null) {
                  registeredPath.paths.remove(target)
                  if (registeredPath.paths.isEmpty) {
                    watcher.unregister(target)
                    watchedSymlinksByDirectory.remove(target)
                  }
                }
              }
            }
          }
        }
      }
    })
  }

}
