// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.util.Map.Entry
import com.swoval.functional.Filter
import java.nio.file.Path
import java.util.ArrayList
import java.util.HashMap
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.concurrent.ConcurrentHashMap
import DirectoryRegistryImpl._

trait DirectoryRegistry extends Filter[Path] with AutoCloseable {

  def addDirectory(path: Path, maxDepth: Int): Boolean

  def maxDepthFor(path: Path): Int

  def registered(): Map[Path, Integer]

  def removeDirectory(path: Path): Unit

  def acceptPrefix(path: Path): Boolean

  override def close(): Unit

}

object DirectoryRegistries {

  def toTypedPathFilter(registry: DirectoryRegistry): Filter[TypedPath] =
    new Filter[TypedPath]() {
      override def accept(typedPath: TypedPath): Boolean =
        registry.accept(typedPath.getPath)
    }

}

object DirectoryRegistryImpl {

  private class RegisteredDirectory(val path: Path, val maxDepth: Int) {

    val compMaxDepth: Int =
      if (maxDepth == java.lang.Integer.MAX_VALUE) maxDepth else maxDepth + 1

    def accept(path: Path): Boolean =
      path.startsWith(this.path) &&
        (path == this.path ||
          this.path.relativize(path).getNameCount <= compMaxDepth)

    override def toString(): String =
      "RegisteredDirectory(path = " + path + ", depth = " +
        maxDepth +
        ")"

  }

}

class DirectoryRegistryImpl extends DirectoryRegistry {

  private val registeredDirectoriesByPath: Map[Path, RegisteredDirectory] =
    new ConcurrentHashMap()

  private val lock: AnyRef = new AnyRef()

  override def addDirectory(path: Path, maxDepth: Int): Boolean =
    lock.synchronized {
      val registeredDirectory: RegisteredDirectory =
        registeredDirectoriesByPath.get(path)
      if (registeredDirectory == null || maxDepth > registeredDirectory.maxDepth) {
        registeredDirectoriesByPath.put(path, new RegisteredDirectory(path, maxDepth))
        true
      } else {
        false
      }
    }

  override def maxDepthFor(path: Path): Int = lock.synchronized {
    var maxDepth: Int = java.lang.Integer.MIN_VALUE
    val it: Iterator[RegisteredDirectory] =
      registeredDirectoriesByPath.values.iterator()
    while (it.hasNext) {
      val dir: RegisteredDirectory = it.next()
      if (path.startsWith(dir.path)) {
        val depth: Int =
          if (dir.path == path) 0 else dir.path.relativize(path).getNameCount
        val possibleMaxDepth: Int = dir.maxDepth - depth
        if (possibleMaxDepth > maxDepth) {
          maxDepth = possibleMaxDepth
        }
      }
    }
    maxDepth
  }

  override def registered(): Map[Path, Integer] = lock.synchronized {
    val result: Map[Path, Integer] = new HashMap[Path, Integer]()
    val it: Iterator[RegisteredDirectory] =
      registeredDirectoriesByPath.values.iterator()
    while (it.hasNext) {
      val dir: RegisteredDirectory = it.next()
      result.put(dir.path, dir.maxDepth)
    }
    result
  }

  override def removeDirectory(path: Path): Unit = {
    lock.synchronized {
      registeredDirectoriesByPath.remove(path)
    }
  }

  private def acceptImpl(path: Path, acceptPrefix: Boolean): Boolean =
    lock.synchronized {
      var result: Boolean = false
      val it: Iterator[Entry[Path, RegisteredDirectory]] =
        new ArrayList(registeredDirectoriesByPath.entrySet()).iterator()
      while (!result && it.hasNext) {
        val entry: Entry[Path, RegisteredDirectory] = it.next()
        val registeredDirectory: RegisteredDirectory = entry.getValue
        val watchPath: Path = entry.getKey
        if (acceptPrefix && watchPath.startsWith(path)) {
          result = true
        } else if (path.startsWith(watchPath)) {
          result = registeredDirectory.accept(path)
        }
      }
      result
    }

  override def accept(path: Path): Boolean = acceptImpl(path, false)

  override def acceptPrefix(path: Path): Boolean = acceptImpl(path, true)

  override def close(): Unit = {
    registeredDirectoriesByPath.clear()
  }

}
