// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.nio.file.Path
import java.util.{ ArrayList, HashMap, Iterator, List, Map }
import java.util.Map.Entry

import com.swoval.files.DirectoryRegistry._
import com.swoval.functional.Filter

object DirectoryRegistry {

  private class RegisteredDirectory(val path: Path, val maxDepth: Int) {

    val compMaxDepth: Int =
      if (maxDepth == java.lang.Integer.MAX_VALUE) maxDepth else maxDepth + 1

    def accept(path: Path): Boolean =
      path.startsWith(this.path) &&
        (path == this.path ||
          this.path.relativize(path).getNameCount <= compMaxDepth)

    override def toString(): String =
      "RegisteredDirectory(path = " + path + ", depth = " +
        maxDepth +
        ")"

  }

}

class DirectoryRegistry extends Filter[Path] {

  private val registeredDirectoriesByPath: Map[Path, RegisteredDirectory] =
    new HashMap()

  def registeredDirectories(): List[Path] =
    new ArrayList(registeredDirectoriesByPath.keySet)

  def addDirectory(path: Path, maxDepth: Int): Unit = {
    val registeredDirectory: RegisteredDirectory =
      registeredDirectoriesByPath.get(path)
    if (registeredDirectory == null || maxDepth > registeredDirectory.maxDepth) {
      registeredDirectoriesByPath.put(path, new RegisteredDirectory(path, maxDepth))
    }
  }

  def maxDepthFor(path: Path): Int = {
    var maxDepth: Int = java.lang.Integer.MIN_VALUE
    val it: Iterator[RegisteredDirectory] =
      registeredDirectoriesByPath.values.iterator()
    while (it.hasNext) {
      val dir: RegisteredDirectory = it.next()
      if (path.startsWith(dir.path)) {
        val depth: Int =
          if (dir.path == path) 0 else dir.path.relativize(path).getNameCount
        val possibleMaxDepth: Int = dir.maxDepth - depth
        if (possibleMaxDepth > maxDepth) {
          maxDepth = possibleMaxDepth
        }
      }
    }
    maxDepth
  }

  def removeDirectory(path: Path): Unit = {
    val registeredDirectory: RegisteredDirectory =
      registeredDirectoriesByPath.remove(path)
  }

  override def accept(path: Path): Boolean = {
    var result: Boolean = false
    val it: Iterator[Entry[Path, RegisteredDirectory]] =
      registeredDirectoriesByPath.entrySet().iterator()
    while (!result && it.hasNext) {
      val entry: Entry[Path, RegisteredDirectory] = it.next()
      val registeredDirectory: RegisteredDirectory = entry.getValue
      val watchPath: Path = entry.getKey
      if (watchPath.startsWith(path)) {
        result = true
      } else if (path.startsWith(watchPath)) {
        result = registeredDirectory.accept(path)
      }
    }
    result
  }

}
