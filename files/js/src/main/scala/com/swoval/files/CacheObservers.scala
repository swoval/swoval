// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.FileTreeDataViews.Entry
import com.swoval.files.FileTreeViews.CacheObserver
import com.swoval.files.FileTreeViews.Observer
import java.io.IOException
import java.util.ArrayList
import java.util.Iterator
import java.util.LinkedHashMap
import java.util.List
import java.util.Map
import java.util.concurrent.atomic.AtomicInteger
import CacheObservers._

object CacheObservers {

  def fromObserver[T](observer: Observer[Entry[T]]): CacheObserver[T] =
    new CacheObserver[T]() {
      override def onCreate(newEntry: Entry[T]): Unit = {
        observer.onNext(newEntry)
      }

      override def onDelete(oldEntry: Entry[T]): Unit = {
        observer.onNext(oldEntry)
      }

      override def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit = {
        observer.onNext(newEntry)
      }

      override def onError(exception: IOException): Unit = {
        observer.onError(exception)
      }
    }

}

class CacheObservers[T] extends FileTreeViews.CacheObserver[T] with AutoCloseable {

  private val counter: AtomicInteger = new AtomicInteger(0)

  private val observers: Map[Integer, CacheObserver[T]] = new LinkedHashMap()

  override def onCreate(newEntry: Entry[T]): Unit = {
    var cbs: List[CacheObserver[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[CacheObserver[T]] = cbs.iterator()
    while (it.hasNext) try it.next().onCreate(newEntry)
    catch {
      case e: Exception => e.printStackTrace()

    }
  }

  override def onDelete(oldEntry: Entry[T]): Unit = {
    var cbs: List[FileTreeViews.CacheObserver[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[FileTreeViews.CacheObserver[T]] = cbs.iterator()
    while (it.hasNext) try it.next().onDelete(oldEntry)
    catch {
      case e: Exception => e.printStackTrace()

    }
  }

  override def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit = {
    var cbs: List[FileTreeViews.CacheObserver[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[FileTreeViews.CacheObserver[T]] = cbs.iterator()
    while (it.hasNext) try it.next().onUpdate(oldEntry, newEntry)
    catch {
      case e: Exception => e.printStackTrace()

    }
  }

  override def onError(exception: IOException): Unit = {
    var cbs: List[FileTreeViews.CacheObserver[T]] = null
    observers.synchronized {
      cbs = new ArrayList(observers.values)
    }
    val it: Iterator[FileTreeViews.CacheObserver[T]] = cbs.iterator()
    while (it.hasNext) it.next().onError(exception)
  }

  /**
   * Add an cacheObserver to receive events.
   *
   * @param observer the new cacheObserver
   * @return a handle to the added cacheObserver that can be used to halt observation using [[    com.swoval.files.Observers.removeObserver]] .
   */
  def addObserver(observer: Observer[Entry[T]]): Int = {
    val key: Int = counter.getAndIncrement
    observers.synchronized {
      observers.put(key, CacheObservers.fromObserver(observer))
    }
    key
  }

  def addCacheObserver(cacheObserver: FileTreeViews.CacheObserver[T]): Int = {
    val key: Int = counter.getAndIncrement
    observers.synchronized {
      observers.put(key, cacheObserver)
    }
    key
  }

  /**
   * Remove an instance of [[FileTreeViews.CacheObserver]] that was previously added using
   * [[com.swoval.files.Observers.addObserver]].
   *
   * @param handle the handle to remove
   */
  def removeObserver(handle: Int): Unit = {
    observers.synchronized {
      observers.remove(handle)
    }
  }

  override def close(): Unit = {
    observers.clear()
  }

}
