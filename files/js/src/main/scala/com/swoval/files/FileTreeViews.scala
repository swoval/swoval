// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.FileTreeDataViews.Converter
import com.swoval.files.FileTreeDataViews.Entry
import com.swoval.functional.Filter
import com.swoval.functional.Filters
import java.io.IOException
import java.nio.file.Path
import java.util.ArrayList
import java.util.Collections
import java.util.Iterator
import java.util.List

object FileTreeViews {

  val listers: Array[DirectoryLister] = DirectoryListers.init()

  val nioLister: DirectoryLister = new NioDirectoryLister()

  val defaultLister: DirectoryLister =
    if (listers(1) != null) listers(1)
    else if (listers(0) != null) listers(0)
    else nioLister

  private val nioDirectoryLister: DirectoryLister = nioLister

  private val nativeDirectoryLister: DirectoryLister = listers(0)

  private val defaultDirectoryLister: DirectoryLister = defaultLister

  private val defaultFileTreeView: FileTreeView =
    new SimpleFileTreeView(defaultLister, false)

  private val PATH_CONVERTER: Converter[Path] = new Converter[Path]() {
    override def apply(typedPath: TypedPath): Path = typedPath.getPath
  }

  /**
   * Make a new CachedDirectory with no cache value associated with the path.
   *
   * @param path the path to monitor
   * @param depth sets how the limit for how deep to traverse the children of this directory
   * @param followLinks sets whether or not to treat symbolic links whose targets as directories or
   *     files
   * @return a directory whose entries just contain the path itself.
   */
  def of(path: Path, depth: Int, followLinks: Boolean): DirectoryView =
    new CachedDirectoryImpl(path,
                            path,
                            PATH_CONVERTER,
                            depth,
                            Filters.AllPass,
                            getDefault(followLinks)).init()

  /**
   * Make a new CachedDirectory with a cache entries created by {@code converter}.
   *
   * @param path the path to cache
   * @param converter a function to create the cache value for each path
   * @param depth determines how many levels of children of subdirectories to include in the results
   * @param followLinks sets whether or not to treat symbolic links whose targets as directories or
   *     files
   * @tparam T the cache value type
   * @return a directory with entries of type T.
   */
  def cached[T <: AnyRef](path: Path,
                          converter: Converter[T],
                          depth: Int,
                          followLinks: Boolean): CachedDirectory[T] =
    new CachedDirectoryImpl(path, path, converter, depth, Filters.AllPass, getDefault(followLinks))
      .init()

  /**
   * Returns an instance of [[FileTreeView]] that uses only apis available in java.nio.file.
   * This may be used on platforms for which there is no native implementation of [[FileTreeView]].
   *
   * @param followLinks toggles whether or not to follow the targets of symbolic links to
   *     directories.
   * @return an instance of [[FileTreeView]].
   */
  def getNio(followLinks: Boolean): FileTreeView =
    new SimpleFileTreeView(nioDirectoryLister, followLinks)

  /**
   * Returns an instance of [[FileTreeView]] that uses native jni functions to improve
   * performance compared to the [[FileTreeView]] returned by [[FileTreeViews.getNio]].
   *
   * @param followLinks toggles whether or not to follow the targets of symbolic links to
   *     directories.
   * @return an instance of [[FileTreeView]].
   */
  def getNative(followLinks: Boolean): FileTreeView =
    new SimpleFileTreeView(nativeDirectoryLister, followLinks)

  /**
   * Returns the default [[FileTreeView]] for the runtime platform. If a native implementation
   * is present, it will be used. Otherwise, it will fall back to the java.nio.file based
   * implementation.
   *
   * @param followLinks toggles whether or not to follow the targets of symbolic links to
   *     directories.
   * @return an instance of [[FileTreeView]].
   */
  def getDefault(followLinks: Boolean): FileTreeView =
    new SimpleFileTreeView(defaultDirectoryLister, followLinks)

  /**
   * List the contents of a path.
   * @param path the path to list. If the path is a directory, return the children of this directory
   * up to the maxDepth. If the path is a regular file and the maxDepth is <code>-1</code>, the
   * path itself is returned. Otherwise an empty list is returned.
   * @param maxDepth the maximum depth of children to include in the results
   * @param filter only include paths accepted by this filter
   * @return a [[java.util.List]] of [[TypedPath]]
   */
  def list(path: Path, maxDepth: Int, filter: Filter[_ >: TypedPath]): List[TypedPath] =
    defaultFileTreeView.list(path, maxDepth, filter)

  /**
   * Generic Observer for an [[Observable]].
   * @tparam T the type under observation
   */
  trait Observer[T] {

    /**
     * Fired if the underlying [[Observable]] encounters an error
     * @param t the error
     */
    def onError(t: Throwable): Unit

    /**
     * Callback that is invoked whenever a change is detected by the [[Observable]].
     * @param t the changed instance
     */
    def onNext(t: T): Unit

  }

  /**
   * Provides callbacks to run when different types of file events are detected by the cache.
   *
   * @tparam T the type for the [[FileTreeDataViews.Entry]] data
   */
  trait CacheObserver[T] {

    /**
     * Callback to fire when a new path is created.
     *
     * @param newEntry the [[FileTreeDataViews.Entry]] for the newly created file
     */
    def onCreate(newEntry: Entry[T]): Unit

    /**
     * Callback to fire when a path is deleted.
     *
     * @param oldEntry the [[Entry]] for the deleted.
     */
    def onDelete(oldEntry: Entry[T]): Unit

    /**
     * Callback to fire when a path is modified.
     *
     * @param oldEntry the [[Entry]] for the updated path
     * @param newEntry the [[Entry]] for the deleted path
     */
    def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit

    /**
     * Callback to fire when an error is encountered generating while updating a path.
     *
     * @param exception The exception thrown by the computation
     */
    def onError(exception: IOException): Unit

  }

  trait Observable[T] {

    /**
     * Add an observer of events.
     *
     * @param observer the observer to add
     * @return the handle to the observer.
     */
    def addObserver(observer: Observer[T]): Int

    /**
     * Remove an observer.
     *
     * @param handle the handle that was returned by addObserver
     */
    def removeObserver(handle: Int): Unit

  }

  trait ObservableCache[T] extends Observable[Entry[T]] {

    /**
     * Add an observer of cache events.
     *
     * @param observer the observer to add
     * @return the handle to the observer.
     */
    def addCacheObserver(observer: CacheObserver[T]): Int

  }

  class Updates[T] extends CacheObserver[T] {

    private val creations: List[Entry[T]] = new ArrayList()

    private val deletions: List[Entry[T]] = new ArrayList()

    private val updates: List[Array[Entry[T]]] = new ArrayList()

    def observe(cacheObserver: CacheObserver[T]): Unit = {
      Collections.sort(creations)
      val creationIterator: Iterator[Entry[T]] = creations.iterator()
      while (creationIterator.hasNext) cacheObserver.onCreate(creationIterator.next())
      val updateIterator: Iterator[Array[Entry[T]]] = updates.iterator()
      while (updateIterator.hasNext) {
        val entries: Array[Entry[T]] = updateIterator.next()
        cacheObserver.onUpdate(entries(0), entries(1))
      }
      val deletionIterator: Iterator[Entry[T]] = deletions.iterator()
      while (deletionIterator.hasNext) cacheObserver.onDelete(
        Entries.setExists(deletionIterator.next(), false))
    }

    override def onCreate(newEntry: Entry[T]): Unit = {
      creations.add(newEntry)
    }

    override def onDelete(oldEntry: Entry[T]): Unit = {
      deletions.add(oldEntry)
    }

    override def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit = {
      updates.add(Array(oldEntry, newEntry))
    }

    override def onError(exception: IOException): Unit = {}

  }

}
