// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.io.IOException
import java.nio.file.Path
import java.util.{ ArrayList, Collections, Iterator, List }

import com.swoval.files.DataViews.{ Converter, Entry }
import com.swoval.functional.{ Filter, Filters }

object FileTreeViews {

  val listers: Array[DirectoryLister] = DirectoryListers.init()

  val nioLister: DirectoryLister = new NioDirectoryLister()

  val defaultLister: DirectoryLister =
    if (listers(1) != null) listers(1)
    else if (listers(0) != null) listers(0)
    else nioLister

  private val nioDirectoryLister: DirectoryLister = nioLister

  private val nativeDirectoryLister: DirectoryLister = listers(0)

  private val defaultDirectoryLister: DirectoryLister = defaultLister

  private val defaultFileTreeView: FileTreeView =
    new SimpleFileTreeView(defaultLister, false)

  private val PATH_CONVERTER: Converter[Path] = new Converter[Path]() {
    override def apply(typedPath: TypedPath): Path = typedPath.getPath
  }

  /**
   * Make a new CachedDirectory with no cache value associated with the path.
   *
   * @param path the path to monitor
   * @param depth sets how the limit for how deep to traverse the children of this directory
   * @param followLinks sets whether or not to treat symbolic links whose targets as directories or
   *     files
   * @return a directory whose entries just contain the path itself.
   */
  def of(path: Path, depth: Int, followLinks: Boolean): CachedDirectory[Path] =
    new CachedDirectoryImpl(path,
                            path,
                            PATH_CONVERTER,
                            depth,
                            Filters.AllPass,
                            getDefault(followLinks)).init()

  /**
   * Make a new CachedDirectory with a cache entries created by {@code converter}.
   *
   * @param path the path to cache
   * @param converter a function to create the cache value for each path
   * @param depth determines how many levels of children of subdirectories to include in the results
   * @tparam T the cache value type
   * @return a directory with entries of type T.
   */
  def cached[T <: AnyRef](path: Path, converter: Converter[T], depth: Int): CachedDirectory[T] =
    new CachedDirectoryImpl(path, path, converter, depth, Filters.AllPass, getDefault(false)).init()

  /**
   * Returns an instance of [[FileTreeView]] that uses only apis available in java.nio.file.
   * This may be used on platforms for which there is no native implementation of [[FileTreeView]].
   *
   * @param followLinks toggles whether or not to follow the targets of symbolic links to
   *     directories.
   * @return an instance of [[FileTreeView]].
   */
  def getNio(followLinks: Boolean): FileTreeView =
    new SimpleFileTreeView(nioDirectoryLister, followLinks)

  /**
   * Returns an instance of [[FileTreeView]] that uses native jni functions to improve
   * performance compared to the [[FileTreeView]] returned by [[FileTreeViews.getNio]].
   *
   * @param followLinks toggles whether or not to follow the targets of symbolic links to
   *     directories.
   * @return an instance of [[FileTreeView]].
   */
  def getNative(followLinks: Boolean): FileTreeView =
    new SimpleFileTreeView(nativeDirectoryLister, followLinks)

  /**
   * Returns the default [[FileTreeView]] for the runtime platform. If a native implementation
   * is present, it will be used. Otherwise, it will fall back to the java.nio.file based
   * implementation.
   *
   * @param followLinks toggles whether or not to follow the targets of symbolic links to
   *     directories.
   * @return an instance of [[FileTreeView]].
   */
  def getDefault(followLinks: Boolean): FileTreeView =
    new SimpleFileTreeView(defaultDirectoryLister, followLinks)

  def list(path: Path, maxDepth: Int, filter: Filter[_ >: TypedPath]): List[TypedPath] =
    defaultFileTreeView.list(path, maxDepth, filter)

  trait Observer[T] {

    def onError(t: Throwable): Unit

    def onNext(t: T): Unit

  }

  /**
   * Provides callbacks to run when different types of file events are detected by the cache.
   *
   * @tparam T the type for the [[DataViews.Entry]] data
   */
  trait CacheObserver[T] {

    /**
     * Callback to fire when a new path is created.
     *
     * @param newEntry the [[DataViews.Entry]] for the newly created file
     */
    def onCreate(newEntry: Entry[T]): Unit

    /**
     * Callback to fire when a path is deleted.
     *
     * @param oldEntry the [[Entry]] for the deleted.
     */
    def onDelete(oldEntry: Entry[T]): Unit

    /**
     * Callback to fire when a path is modified.
     *
     * @param oldEntry the [[Entry]] for the updated path
     * @param newEntry the [[Entry]] for the deleted path
     */
    def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit

    /**
     * Callback to fire when an error is encountered generating while updating a path.
     *
     * @param exception The exception thrown by the computation
     */
    def onError(exception: IOException): Unit

  }

  trait Observable[T] {

    /**
     * Add an observer of events.
     *
     * @param observer the observer to add
     * @return the handle to the observer.
     */
    def addObserver(observer: Observer[T]): Int

    /**
     * Remove an observer.
     *
     * @param handle the handle that was returned by addObserver
     */
    def removeObserver(handle: Int): Unit

  }

  trait ObservableCache[T] extends Observable[Entry[T]] {

    /**
     * Add an observer of cache events.
     *
     * @param observer the observer to add
     * @return the handle to the observer.
     */
    def addCacheObserver(observer: CacheObserver[T]): Int

  }

  class Updates[T] extends CacheObserver[T] {

    private val creations: List[Entry[T]] = new ArrayList()

    private val deletions: List[Entry[T]] = new ArrayList()

    private val updates: List[Array[Entry[T]]] = new ArrayList()

    def observe(cacheObserver: CacheObserver[T]): Unit = {
      Collections.sort(creations)
      val creationIterator: Iterator[Entry[T]] = creations.iterator()
      while (creationIterator.hasNext) cacheObserver.onCreate(creationIterator.next())
      val updateIterator: Iterator[Array[Entry[T]]] = updates.iterator()
      while (updateIterator.hasNext) {
        val entries: Array[Entry[T]] = updateIterator.next()
        cacheObserver.onUpdate(entries(0), entries(1))
      }
      val deletionIterator: Iterator[Entry[T]] = deletions.iterator()
      while (deletionIterator.hasNext) cacheObserver.onDelete(deletionIterator.next())
    }

    override def onCreate(newEntry: Entry[T]): Unit = {
      creations.add(newEntry)
    }

    override def onDelete(oldEntry: Entry[T]): Unit = {
      deletions.add(oldEntry)
    }

    override def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit = {
      updates.add(Array(oldEntry, newEntry))
    }

    override def onError(exception: IOException): Unit = {}

  }

}
