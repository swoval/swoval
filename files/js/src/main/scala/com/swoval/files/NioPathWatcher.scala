// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.PathWatchers.Event.Kind.Create
import com.swoval.files.PathWatchers.Event.Kind.Delete
import com.swoval.files.PathWatchers.Event.Kind.Modify
import com.swoval.functional.Filters.AllPass
import java.util.Map.Entry
import com.swoval.files.Executor.ThreadHandle
import com.swoval.files.FileTreeDataViews.Converter
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.files.PathWatchers.Event.Kind
import com.swoval.files.PathWatchers.Overflow
import com.swoval.functional.Consumer
import com.swoval.functional.Either
import com.swoval.functional.Filter
import com.swoval.runtime.Platform
import java.io.IOException
import java.nio.file.Path
import java.util.ArrayList
import java.util.Iterator
import java.util.LinkedHashMap
import java.util.List
import java.util.Map
import java.util.concurrent.atomic.AtomicBoolean

/**
 Provides a PathWatcher that is backed by a [[java.nio.file.WatchService]].
 */
class NioPathWatcher(private val directoryRegistry: DirectoryRegistry,
                     watchService: RegisterableWatchService,
                     private val internalExecutor: Executor)
    extends PathWatcher[PathWatchers.Event]
    with AutoCloseable {

  private val closed: AtomicBoolean = new AtomicBoolean(false)

  private val observers: Observers[PathWatchers.Event] = new Observers()

  private val rootDirectories: Map[Path, CachedDirectory[WatchedDirectory]] =
    new LinkedHashMap()

  private val converter: Converter[WatchedDirectory] =
    new Converter[WatchedDirectory]() {
      override def apply(typedPath: TypedPath): WatchedDirectory =
        if (typedPath.isDirectory)
          Either.getOrElse(service.register(typedPath.getPath), WatchedDirectories.INVALID)
        else WatchedDirectories.INVALID
    }

  private val updateCacheObserver: FileTreeViews.CacheObserver[WatchedDirectory] =
    new FileTreeViews.CacheObserver[WatchedDirectory]() {
      override def onCreate(newEntry: FileTreeDataViews.Entry[WatchedDirectory]): Unit = {
        maybeRunCallback(new Event(newEntry, Create))
        try {
          val it: Iterator[TypedPath] = FileTreeViews
            .list(newEntry.getPath, 0, new Filter[TypedPath]() {
              override def accept(typedPath: TypedPath): Boolean =
                directoryRegistry.accept(typedPath.getPath)
            })
            .iterator()
          while (it.hasNext) {
            val tp: TypedPath = it.next()
            maybeRunCallback(new Event(tp, Create))
          }
        } catch {
          case e: IOException => {}

        }
      }

      override def onDelete(oldEntry: FileTreeDataViews.Entry[WatchedDirectory]): Unit = {
        if (oldEntry.getValue.isRight) oldEntry.getValue.get.close()
        maybeRunCallback(new Event(oldEntry, Delete))
      }

      override def onUpdate(oldEntry: FileTreeDataViews.Entry[WatchedDirectory],
                            newEntry: FileTreeDataViews.Entry[WatchedDirectory]): Unit = {}

      override def onError(exception: IOException): Unit = {}
    }

  private val service: NioPathWatcherService = new NioPathWatcherService(
    new Consumer[Either[Overflow, Event]]() {
      override def accept(either: Either[Overflow, Event]): Unit = {
        if (!closed.get) {
          internalExecutor.run(new Consumer[ThreadHandle]() {
            override def accept(threadHandle: ThreadHandle): Unit = {
              if (either.isRight) {
                val event: Event = either.get
                handleEvent(new Event(TypedPaths.get(event.getPath), event.getKind), threadHandle)
              } else {
                handleOverflow(Either.leftProjection(either).getValue, threadHandle)
              }
            }
          })
        }
      }
    },
    watchService,
    internalExecutor
  )

  /**
   * Similar to register, but tracks all of the new files found in the directory. It polls the
   * directory until the contents stop changing to ensure that a callback is fired for each path in
   * the newly created directory (up to the maxDepth). The assumption is that once the callback is
   * fired for the path, it is safe to assume that no event for a new file in the directory is
   * missed. Without the polling, it would be possible that a new file was created in the directory
   * before we registered it with the watch service. If this happened, then no callback would be
   * invoked for that file.
   *
   * @param typedPath The newly created directory to add
   */
  def add(typedPath: TypedPath, threadHandle: ThreadHandle): Unit = {
    if (directoryRegistry.maxDepthFor(typedPath.getPath) >= 0) {
      val dir: CachedDirectory[WatchedDirectory] =
        getOrAdd(typedPath.getPath, threadHandle)
      if (dir != null) {
        update(dir, typedPath, threadHandle)
      }
    }
  }

  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] = {
    var either: Either[IOException, Boolean] = Either.right(false)
    try {
      val threadHandle: ThreadHandle = internalExecutor.getThreadHandle
      try {
        val existingMaxDepth: Int = directoryRegistry.maxDepthFor(path)
        val result: Boolean = existingMaxDepth < maxDepth
        either = Either.right(result)
        val typedPath: TypedPath = TypedPaths.get(path)
        val realPath: Path = typedPath.toRealPath()
        if (result) {
          directoryRegistry.addDirectory(typedPath.getPath, maxDepth)
        }
        val dir: CachedDirectory[WatchedDirectory] = getOrAdd(realPath)
        if (dir != null) {
          val directories: List[FileTreeDataViews.Entry[WatchedDirectory]] =
            dir.listEntries(typedPath.getPath, -1, AllPass)
          if (result || directories.isEmpty || directories
                .get(0)
                .getValue
                .isRight) {
            val toUpdate: Path = typedPath.getPath
            if (toUpdate != null) update(dir, typedPath, threadHandle)
          }
        }
      } finally threadHandle.release()
    } catch {
      case e: InterruptedException => either = Either.right(false)

    }
    either
  }

  private def findOrAddRoot(rawPath: Path): CachedDirectory[WatchedDirectory] = {
    val parent: Path = if (Platform.isMac) rawPath else rawPath.getRoot
    val path: Path = if (parent == null) rawPath.getRoot else parent
    assert((path != null))
    val it: Iterator[Entry[Path, CachedDirectory[WatchedDirectory]]] =
      rootDirectories.entrySet().iterator()
    var result: CachedDirectory[WatchedDirectory] = null
    val toRemove: List[Path] = new ArrayList[Path]()
    while (result == null && it.hasNext) {
      val entry: Entry[Path, CachedDirectory[WatchedDirectory]] = it.next()
      val root: Path = entry.getKey
      if (path.startsWith(root)) {
        result = entry.getValue
      } else if (root.startsWith(path) && path != root) {
        toRemove.add(root)
      }
    }
    if (result == null) {
      var toAdd: Path = path
      var init: Boolean = false
      while (!init && toAdd != null) try {
        result = new CachedDirectoryImpl(
          toAdd,
          toAdd,
          converter,
          java.lang.Integer.MAX_VALUE,
          new Filter[TypedPath]() {
            override def accept(typedPath: TypedPath): Boolean =
              typedPath.isDirectory && directoryRegistry.acceptPrefix(typedPath.getPath)
          },
          FileTreeViews.getDefault(false)
        ).init()
        init = true
        rootDirectories.put(toAdd, result)
      } catch {
        case e: IOException => toAdd = toAdd.getParent

      }
    }
    val toRemoveIterator: Iterator[Path] = toRemove.iterator()
    while (toRemoveIterator.hasNext) rootDirectories.remove(toRemoveIterator.next())
    result
  }

  private def getOrAdd(path: Path): CachedDirectory[WatchedDirectory] = {
    val threadHandle: ThreadHandle = internalExecutor.getThreadHandle
    try getOrAdd(path, threadHandle)
    finally threadHandle.release()
  }

  private def getOrAdd(path: Path,
                       threadHandle: ThreadHandle): CachedDirectory[WatchedDirectory] = {
    var result: CachedDirectory[WatchedDirectory] = null
    if (!closed.get) {
      result = findOrAddRoot(path)
    }
    result
  }

  override def unregister(path: Path): Unit = {
    try {
      val threadHandle: ThreadHandle = internalExecutor.getThreadHandle
      try {
        directoryRegistry.removeDirectory(path)
        val dir: CachedDirectory[WatchedDirectory] =
          rootDirectories.get(path.getRoot)
        if (dir != null) {
          val depth: Int = dir.getPath.relativize(path).getNameCount
          val toRemove: List[FileTreeDataViews.Entry[WatchedDirectory]] =
            dir.listEntries(
              depth,
              new Filter[FileTreeDataViews.Entry[WatchedDirectory]]() {
                override def accept(entry: FileTreeDataViews.Entry[WatchedDirectory]): Boolean =
                  !directoryRegistry.acceptPrefix(entry.getPath)
              }
            )
          val it: Iterator[FileTreeDataViews.Entry[WatchedDirectory]] =
            toRemove.iterator()
          while (it.hasNext) {
            val entry: FileTreeDataViews.Entry[WatchedDirectory] = it.next()
            if (!directoryRegistry.acceptPrefix(entry.getPath)) {
              val toCancel: Iterator[FileTreeDataViews.Entry[WatchedDirectory]] =
                dir.remove(entry.getPath, threadHandle).iterator()
              while (toCancel.hasNext) {
                val either: Either[IOException, WatchedDirectory] =
                  toCancel.next().getValue
                if (either.isRight) either.get.close()
              }
            }
          }
        }
      } finally threadHandle.release()
    } catch {
      case e: InterruptedException => {}

    }
  }

  override def close(): Unit = {
    try {
      val threadHandle: ThreadHandle = internalExecutor.getThreadHandle
      try if (closed.compareAndSet(false, true)) {
        service.close()
        val it: Iterator[CachedDirectory[WatchedDirectory]] =
          rootDirectories.values.iterator()
        while (it.hasNext) {
          val either: Either[IOException, WatchedDirectory] =
            it.next().getEntry.getValue
          if (either.isRight) either.get.close()
        }
        rootDirectories.clear()
      } finally threadHandle.release()
    } catch {
      case e: InterruptedException => {}

    }
    internalExecutor.close()
  }

  private def update(dir: CachedDirectory[WatchedDirectory],
                     typedPath: TypedPath,
                     threadHandle: ThreadHandle): Unit = {
    dir.update(typedPath, threadHandle).observe(updateCacheObserver)
  }

  private def handleOverflow(overflow: Overflow, threadHandle: ThreadHandle): Unit = {
    val path: Path = overflow.getPath
    val root: CachedDirectory[WatchedDirectory] = getOrAdd(path, threadHandle)
    if (root != null) {
      try {
        val it: Iterator[TypedPath] = FileTreeViews
          .list(
            path,
            0,
            new Filter[TypedPath]() {
              override def accept(typedPath: TypedPath): Boolean =
                typedPath.isDirectory && directoryRegistry.acceptPrefix(typedPath.getPath)
            }
          )
          .iterator()
        while (it.hasNext) {
          val file: TypedPath = it.next()
          add(file, threadHandle)
        }
      } catch {
        case e: IOException => {
          val removed: Iterator[FileTreeDataViews.Entry[WatchedDirectory]] =
            root.remove(path, threadHandle).iterator()
          while (removed.hasNext) maybeRunCallback(
            new Event(Entries.setExists(removed.next(), false), Delete))
        }

      }
    }
    maybeRunCallback(new Event(TypedPaths.get(path), Modify))
  }

  private def maybeRunCallback(event: Event): Unit = {
    if (directoryRegistry.accept(event.getPath)) {
      observers.onNext(event)
    }
  }

  private def handleEvent(event: Event, threadHandle: ThreadHandle): Unit = {
    if (directoryRegistry.acceptPrefix(event.getPath)) {
      val typedPath: TypedPath = TypedPaths.get(event.getPath)
      if (!typedPath.exists()) {
        val root: CachedDirectory[WatchedDirectory] =
          getOrAdd(event.getPath, threadHandle)
        if (root != null) {
          val isRoot: Boolean = root.getPath == event.getPath
          val it: Iterator[FileTreeDataViews.Entry[WatchedDirectory]] =
            if (isRoot) root.listEntries(root.getMaxDepth, AllPass).iterator()
            else root.remove(event.getPath, threadHandle).iterator()
          while (it.hasNext) {
            val entry: FileTreeDataViews.Entry[WatchedDirectory] = it.next()
            val either: Either[IOException, WatchedDirectory] = entry.getValue
            if (either.isRight) {
              either.get.close()
            }
            maybeRunCallback(new Event(entry, Kind.Delete))
          }
          if (isRoot) {
            rootDirectories.remove(root.getPath)
            getOrAdd(event.getPath, threadHandle)
          }
        }
      }
      maybeRunCallback(event)
      if (typedPath.isDirectory) {
        add(typedPath, threadHandle)
      }
    }
  }

  override def addObserver(observer: Observer[Event]): Int =
    observers.addObserver(observer)

  override def removeObserver(handle: Int): Unit = {
    observers.removeObserver(handle)
  }

}
