// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.Directory.Entries.DIRECTORY
import com.swoval.files.EntryFilters.AllPass
import com.swoval.files.PathWatchers.Event.Create
import com.swoval.files.PathWatchers.Event.Overflow
import com.swoval.files.Directory.Converter
import com.swoval.files.Directory.Entry
import com.swoval.files.Directory.EntryFilter
import com.swoval.files.Directory.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.functional.Consumer
import com.swoval.functional.Either
import com.swoval.functional.Filter
import java.io.IOException
import java.nio.file.FileSystemLoopException
import java.nio.file.Files
import java.nio.file.NoSuchFileException
import java.nio.file.Path
import java.util.Collections
import java.util.HashMap
import java.util.HashSet
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Set
import java.util.concurrent.Callable
import java.util.concurrent.atomic.AtomicBoolean

/**
 Provides a PathWatcher that is backed by a [[java.nio.file.WatchService]].
 */
class NioPathWatcher(callback: Consumer[Event],
                     registerableWatchService: RegisterableWatchService,
                     private val callbackExecutor: Executor,
                     private val internalExecutor: Executor,
                     managedDirectoryRegistry: DirectoryRegistry)
    extends PathWatcher {

  private val closed: AtomicBoolean = new AtomicBoolean(false)

  private val rootDirectories: Map[Path, Directory[WatchedDirectory]] =
    new HashMap()

  private val managed: Boolean = managedDirectoryRegistry != null

  private val directoryRegistry: DirectoryRegistry =
    if (managedDirectoryRegistry == null) new DirectoryRegistry()
    else managedDirectoryRegistry

  private val converter: Converter[WatchedDirectory] =
    new Converter[WatchedDirectory]() {
      override def apply(path: Path): WatchedDirectory =
        nioPathWatcherService
          .register(path)
          .getOrElse(WatchedDirectories.INVALID)
    }

  private val nioPathWatcherService: NioPathWatcherService =
    new NioPathWatcherService(
      new Consumer[Event]() {
        override def accept(event: Event): Unit = {
          handleEvent(callback, event)
        }
      },
      new Consumer[Path]() {
        override def accept(path: Path): Unit = {
          handleOverflow(callback, path)
        }
      },
      registerableWatchService,
      internalExecutor
    )

  private val updateObserver: Directory.Observer[WatchedDirectory] =
    new Observer[WatchedDirectory]() {
      override def onCreate(newEntry: Directory.Entry[WatchedDirectory]): Unit = {}

      override def onDelete(oldEntry: Directory.Entry[WatchedDirectory]): Unit = {
        oldEntry.getValue.close()
      }

      override def onUpdate(oldEntry: Directory.Entry[WatchedDirectory],
                            newEntry: Directory.Entry[WatchedDirectory]): Unit = {}

      override def onError(path: Path, exception: IOException): Unit = {}
    }

  /**
   * Register a path to monitor for file events
   *
   * @param path The directory to watch for file events
   * @param maxDepth The maximum maxDepth of subdirectories to watch
   * @return an [[com.swoval.functional.Either]] containing the result of the registration or an
   *     IOException if registration fails. This method should be idempotent and return true the
   *     first time the directory is registered or when the depth is changed. Otherwise it should
   *     return false.
   */
  override def register(path: Path,
                        maxDepth: Int): com.swoval.functional.Either[IOException, Boolean] =
    internalExecutor
      .block(new Callable[Boolean]() {
        override def call(): Boolean = registerImpl(path, maxDepth)
      })
      .castLeft(classOf[IOException])

  override def register(path: Path, recursive: Boolean): Either[IOException, Boolean] =
    register(path, if (recursive) java.lang.Integer.MAX_VALUE else 0)

  override def register(path: Path): Either[IOException, Boolean] =
    register(path, java.lang.Integer.MAX_VALUE)

  /**
   * Stop watching a directory
   *
   * @param path The directory to remove from monitoring
   */
  override def unregister(path: Path): Unit = {
    internalExecutor.block(new Runnable() {
      override def run(): Unit = {
        if (!managed) directoryRegistry.removeDirectory(path)
        val dir: Directory[WatchedDirectory] = getRoot(path.getRoot)
        if (dir != null) {
          val toRemove: List[Directory.Entry[WatchedDirectory]] =
            dir.list(true, new EntryFilter[WatchedDirectory]() {
              override def accept(entry: Entry[_ <: WatchedDirectory]): Boolean =
                !directoryRegistry.accept(entry.getPath)
            })
          Collections.sort(toRemove)
          val it: Iterator[Directory.Entry[WatchedDirectory]] =
            toRemove.iterator()
          while (it.hasNext) {
            val entry: Directory.Entry[WatchedDirectory] = it.next()
            if (!directoryRegistry.accept(entry.getPath)) {
              val toCancel: Iterator[Directory.Entry[WatchedDirectory]] =
                dir.remove(entry.getPath).iterator()
              while (toCancel.hasNext) toCancel.next().getValue.close()
            }
          }
        }
      }
    })
  }

  override def close(): Unit = {
    if (closed.compareAndSet(false, true)) {
      internalExecutor.block(new Runnable() {
        override def run(): Unit = {
          callbackExecutor.close()
          val it: Iterator[Directory[WatchedDirectory]] =
            rootDirectories.values.iterator()
          while (it.hasNext) {
            val dir: Directory[WatchedDirectory] = it.next()
            dir.entry().getValue.close()
            val entries: Iterator[Directory.Entry[WatchedDirectory]] =
              dir.list(true, AllPass).iterator()
            while (entries.hasNext) entries.next().getValue.close()
          }
          nioPathWatcherService.close()
        }
      })
      internalExecutor.close()
    }
  }

  private def maybeRunCallback(callback: Consumer[Event], event: Event): Unit = {
    if (directoryRegistry.accept(event.getPath)) {
      callbackExecutor.run(new Runnable() {
        override def run(): Unit = {
          callback.accept(event)
        }
      })
    }
  }

  private def processPath(callback: Consumer[Event],
                          path: Path,
                          kind: Event.Kind,
                          processedDirs: HashSet[QuickFile],
                          processedFiles: HashSet[Path]): Unit = {
    val newFiles: Set[QuickFile] = new HashSet[QuickFile]()
    add(path, newFiles)
    if (processedFiles.add(path)) {
      maybeRunCallback(callback, new Event(path, kind))
      val it: Iterator[QuickFile] = newFiles.iterator()
      while (it.hasNext) {
        val file: QuickFile = it.next()
        if (file.isDirectory && processedDirs.add(file)) {
          processPath(callback,
                      file.toPath(),
                      PathWatchers.Event.Create,
                      processedDirs,
                      processedFiles)
        } else if (processedFiles.add(file.toPath())) {
          maybeRunCallback(callback, new Event(file.toPath(), PathWatchers.Event.Create))
        }
      }
    }
  }

  private def handleEvent(callback: Consumer[Event], event: Event): Unit = {
    if (directoryRegistry.accept(event.getPath)) {
      if (!Files.exists(event.getPath)) {
        val root: Directory[WatchedDirectory] =
          rootDirectories.get(event.getPath.getRoot)
        if (root != null) {
          val it: Iterator[Directory.Entry[WatchedDirectory]] =
            root.remove(event.getPath).iterator()
          while (it.hasNext) {
            val watchedDirectory: WatchedDirectory = it.next().getValue
            if (watchedDirectory != null) {
              watchedDirectory.close()
            }
          }
        }
      }
      if (Files.isDirectory(event.getPath)) {
        processPath(callback,
                    event.getPath,
                    event.getKind,
                    new HashSet[QuickFile](),
                    new HashSet[Path]())
      } else {
        maybeRunCallback(callback, event)
      }
    }
  }

  private def handleOverflow(callback: Consumer[Event], path: Path): Unit = {
    val maxDepth: Int = directoryRegistry.maxDepthFor(path)
    var stop: Boolean = false
    while (!stop && maxDepth > 0) try {
      var registered: Boolean = false
      val files: Set[QuickFile] = new HashSet[QuickFile]()
      val directoryIterator: Iterator[Path] =
        directoryRegistry.registeredDirectories().iterator()
      while (directoryIterator.hasNext) files.add(
        new QuickFileImpl(directoryIterator.next().toString, DIRECTORY))
      maybePoll(path, files)
      val it: Iterator[QuickFile] = files.iterator()
      while (it.hasNext) {
        val file: QuickFile = it.next()
        if (file.isDirectory) {
          val regResult: Boolean = registerImpl(file.toPath(),
                                                if (maxDepth == java.lang.Integer.MAX_VALUE)
                                                  java.lang.Integer.MAX_VALUE
                                                else maxDepth - 1)
          registered = registered || regResult
          if (regResult) callbackExecutor.run(new Runnable() {
            override def run(): Unit = {
              callback.accept(new Event(file.toPath(), Create))
            }
          })
        }
      }
      stop = !registered
    } catch {
      case e: NoSuchFileException => stop = false

      case e: IOException => stop = true

    }
    callbackExecutor.run(new Runnable() {
      override def run(): Unit = {
        callback.accept(new Event(path, Overflow))
      }
    })
  }

  private def maybePoll(path: Path, files: Set[QuickFile]): Unit = {
    if (!managed) {
      var result: Boolean = false
      do {
        result = false
        val it: Iterator[QuickFile] = QuickList
          .list(
            path,
            0,
            false,
            new Filter[QuickFile]() {
              override def accept(quickFile: QuickFile): Boolean =
                !quickFile.isDirectory || directoryRegistry.accept(quickFile.toPath())
            }
          )
          .iterator()
        while (it.hasNext) result = files.add(it.next()) || result
      } while (!Thread.currentThread().isInterrupted && result);
    }
  }

  /**
   * Similar to register, but tracks all of the new files found in the directory. It polls the
   * directory until the contents stop changing to ensure that a callback is fired for each path in
   * the newly created directory (up to the maxDepth). The assumption is that once the callback is
   * fired for the path, it is safe to assume that no event for a new file in the directory is
   * missed. Without the polling, it would be possible that a new file was created in the directory
   * before we registered it with the watch service. If this happened, then no callback would be
   * invoked for that file.
   *
   * @param path The newly created directory to add
   * @param newFiles The set of files that are found for the newly created directory
   * @return true if no exception is thrown
   */
  private def add(path: Path, newFiles: Set[QuickFile]): Boolean = {
    var result: Boolean = true
    try {
      if (directoryRegistry.maxDepthFor(path) >= 0) {
        val dir: Directory[WatchedDirectory] = getRoot(path.getRoot)
        if (dir != null) {
          update(dir, path)
        }
      }
      maybePoll(path, newFiles)
    } catch {
      case e: IOException => result = false

    }
    result
  }

  private def getRoot(root: Path): Directory[WatchedDirectory] = {
    var result: Directory[WatchedDirectory] = rootDirectories.get(root)
    if (result == null) {
      try {
        result = new Directory(
          root,
          root,
          converter,
          java.lang.Integer.MAX_VALUE,
          new Filter[QuickFile]() {
            override def accept(quickFile: QuickFile): Boolean =
              directoryRegistry.accept(quickFile.toPath())
          }
        ).init()
        rootDirectories.put(root, result)
      } catch {
        case e: IOException => {}

      }
    }
    result
  }

  private def registerImpl(path: Path, maxDepth: Int): Boolean = {
    val existingMaxDepth: Int = directoryRegistry.maxDepthFor(path)
    val result: Boolean = existingMaxDepth < maxDepth
    var realPath: Path = null
    try realPath = path.toRealPath()
    catch {
      case e: IOException => realPath = path

    }
    if (result && !managed) {
      directoryRegistry.addDirectory(path, maxDepth)
    } else if (path != realPath) {
      /*
       * Note that watchedDir is not null, which means that this path has been
       * registered with a different alias.
       */

      throw new FileSystemLoopException(path.toString)
    }
    val dir: Directory[WatchedDirectory] = getRoot(realPath.getRoot)
    if (dir != null) {
      val directories: List[Directory.Entry[WatchedDirectory]] =
        dir.list(path, -1, AllPass)
      if (result || directories.isEmpty || !directories
            .get(0)
            .getValue
            .isValid) {
        var toUpdate: Path = path
        while (toUpdate != null && !Files.isDirectory(toUpdate)) toUpdate = toUpdate.getParent
        if (toUpdate != null) update(dir, toUpdate)
      }
    }
    result
  }

  private def update(dir: Directory[WatchedDirectory], path: Path): Unit = {
    dir.update(path, DIRECTORY).observe(updateObserver)
  }

}
