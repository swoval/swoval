// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.io.IOException
import java.nio.file.{ FileSystemLoopException, NoSuchFileException, Path }
import java.util.{ HashMap, HashSet, Iterator, List, Map, Set }
import java.util.concurrent.Callable
import java.util.concurrent.atomic.AtomicBoolean

import com.swoval.files.DataViews.{ Converter, Entry }
import com.swoval.files.Entries.DIRECTORY
import com.swoval.files.FileTreeViews.{ Observable, Observer }
import com.swoval.files.PathWatchers.Event
import com.swoval.files.PathWatchers.Event.Kind.{ Create, Overflow }
import com.swoval.functional.{ Consumer, Either, Filter }
import com.swoval.functional.Filters.AllPass

/**
 Provides a PathWatcher that is backed by a [[java.nio.file.WatchService]].
 */
class NioPathWatcher(callback: Consumer[Event],
                     registerableWatchService: RegisterableWatchService,
                     private val internalExecutor: Executor,
                     managedDirectoryRegistry: DirectoryRegistry)
    extends PathWatcher
    with Observable[Event] {

  private val closed: AtomicBoolean = new AtomicBoolean(false)

  private val rootDirectories: Map[Path, CachedDirectoryImpl[WatchedDirectory]] =
    new HashMap()

  private val managed: Boolean = managedDirectoryRegistry != null

  private val directoryRegistry: DirectoryRegistry =
    if (managedDirectoryRegistry == null) new DirectoryRegistry()
    else managedDirectoryRegistry

  private val converter: Converter[WatchedDirectory] =
    new Converter[WatchedDirectory]() {
      override def apply(typedPath: TypedPath): WatchedDirectory =
        if (typedPath.isDirectory)
          Either.getOrElse(nioPathWatcherService.register(typedPath.getPath),
                           WatchedDirectories.INVALID)
        else WatchedDirectories.INVALID
    }

  private val nioPathWatcherService: NioPathWatcherService =
    new NioPathWatcherService(
      new Consumer[Event]() {
        override def accept(event: Event): Unit = {
          handleEvent(callback, event)
        }
      },
      new Consumer[Path]() {
        override def accept(path: Path): Unit = {
          handleOverflow(callback, path)
        }
      },
      registerableWatchService,
      internalExecutor
    )

  private val updateCacheObserver: FileTreeViews.CacheObserver[WatchedDirectory] =
    new FileTreeViews.CacheObserver[WatchedDirectory]() {
      override def onCreate(newEntry: Entry[WatchedDirectory]): Unit = {}

      override def onDelete(oldEntry: Entry[WatchedDirectory]): Unit = {
        close(oldEntry.getValue)
      }

      override def onUpdate(oldEntry: Entry[WatchedDirectory],
                            newEntry: Entry[WatchedDirectory]): Unit = {}

      override def onError(exception: IOException): Unit = {}
    }

  /**
   * Register a path to monitor for file events
   *
   * @param path The directory to watch for file events
   * @param maxDepth The maximum maxDepth of subdirectories to watch
   * @return an [[com.swoval.functional.Either]] containing the result of the registration or an
   *     IOException if registration fails. This method should be idempotent and return true the
   *     first time the directory is registered or when the depth is changed. Otherwise it should
   *     return false.
   */
  override def register(path: Path,
                        maxDepth: Int): com.swoval.functional.Either[IOException, Boolean] =
    internalExecutor
      .block(new Callable[Boolean]() {
        override def call(): Boolean = registerImpl(path, maxDepth)
      })
      .castLeft(classOf[IOException])

  /**
   * Stop watching a directory
   *
   * @param path The directory to remove from monitoring
   */
  override def unregister(path: Path): Unit = {
    internalExecutor.block(new Runnable() {
      override def run(): Unit = {
        if (!managed) directoryRegistry.removeDirectory(path)
        val dir: CachedDirectoryImpl[WatchedDirectory] = getRoot(path.getRoot)
        if (dir != null) {
          val depth: Int = dir.getPath.relativize(path).getNameCount
          val toRemove: List[Entry[WatchedDirectory]] =
            dir.listEntries(depth, new Filter[Entry[WatchedDirectory]]() {
              override def accept(entry: Entry[WatchedDirectory]): Boolean =
                !directoryRegistry.accept(entry.getPath)
            })
          val it: Iterator[Entry[WatchedDirectory]] = toRemove.iterator()
          while (it.hasNext) {
            val entry: Entry[WatchedDirectory] = it.next()
            if (!directoryRegistry.accept(entry.getPath)) {
              val toCancel: Iterator[Entry[WatchedDirectory]] =
                dir.remove(entry.getPath).iterator()
              while (toCancel.hasNext) close(toCancel.next().getValue)
            }
          }
        }
      }
    })
  }

  override def close(): Unit = {
    if (closed.compareAndSet(false, true)) {
      internalExecutor.block(new Runnable() {
        override def run(): Unit = {
          val it: Iterator[CachedDirectoryImpl[WatchedDirectory]] =
            rootDirectories.values.iterator()
          while (it.hasNext) {
            val dir: CachedDirectoryImpl[WatchedDirectory] = it.next()
            close(dir.getEntry.getValue)
            val entries: Iterator[Entry[WatchedDirectory]] =
              dir.listEntries(dir.getMaxDepth, AllPass).iterator()
            while (entries.hasNext) close(entries.next().getValue)
          }
          nioPathWatcherService.close()
        }
      })
      internalExecutor.close()
    }
  }

  private def maybeRunCallback(callback: Consumer[Event], event: Event): Unit = {
    if (directoryRegistry.accept(event.getPath)) {
      callback.accept(event)
    }
  }

  private def processPath(callback: Consumer[Event],
                          path: TypedPath,
                          kind: Event.Kind,
                          processedDirs: HashSet[TypedPath],
                          processedFiles: HashSet[TypedPath]): Unit = {
    val newFiles: Set[TypedPath] = new HashSet[TypedPath]()
    add(path, newFiles)
    if (processedFiles.add(path)) {
      maybeRunCallback(callback, new Event(path, kind))
      val it: Iterator[TypedPath] = newFiles.iterator()
      while (it.hasNext) {
        val file: TypedPath = it.next()
        if (file.isDirectory && processedDirs.add(file)) {
          processPath(callback, file, Create, processedDirs, processedFiles)
        } else if (processedFiles.add(file)) {
          maybeRunCallback(callback, new Event(file, Create))
        }
      }
    }
  }

  private def handleEvent(callback: Consumer[Event], event: Event): Unit = {
    if (directoryRegistry.accept(event.getPath)) {
      val typedPath: TypedPath = TypedPaths.get(event.getPath)
      if (!typedPath.exists()) {
        val root: CachedDirectoryImpl[WatchedDirectory] =
          rootDirectories.get(event.getPath.getRoot)
        if (root != null) {
          val it: Iterator[Entry[WatchedDirectory]] =
            root.remove(event.getPath).iterator()
          while (it.hasNext) close(it.next().getValue)
        }
      }
      if (typedPath.isDirectory) {
        processPath(callback,
                    event,
                    event.getKind,
                    new HashSet[TypedPath](),
                    new HashSet[TypedPath]())
      } else {
        maybeRunCallback(callback, event)
      }
    }
  }

  private def handleOverflow(callback: Consumer[Event], path: Path): Unit = {
    callback.accept(new Event(TypedPaths.get(path), Overflow))
    val maxDepth: Int = directoryRegistry.maxDepthFor(path)
    var stop: Boolean = false
    while (!stop && maxDepth > 0) try {
      var registered: Boolean = false
      val files: Set[TypedPath] = new HashSet[TypedPath]()
      val directoryIterator: Iterator[Path] =
        directoryRegistry.registeredDirectories().iterator()
      while (directoryIterator.hasNext) files.add(
        TypedPaths.get(directoryIterator.next(), DIRECTORY))
      maybePoll(TypedPaths.get(path, DIRECTORY), files)
      val it: Iterator[TypedPath] = files.iterator()
      while (it.hasNext) {
        val file: TypedPath = it.next()
        if (file.isDirectory) {
          val regResult: Boolean = registerImpl(file.getPath,
                                                if (maxDepth == java.lang.Integer.MAX_VALUE)
                                                  java.lang.Integer.MAX_VALUE
                                                else maxDepth - 1)
          registered = registered || regResult
          if (regResult) {
            callback.accept(new Event(file, Create))
          }
        }
      }
      stop = true
    } catch {
      case e: NoSuchFileException => stop = false

      case e: IOException => stop = true

    }
  }

  private def maybePoll(path: TypedPath, files: Set[TypedPath]): Unit = {
// if (!managed) {
    var result: Boolean = false
    do {
      result = false
      try {
        val it: Iterator[TypedPath] = FileTreeViews
          .list(
            path.getPath,
            0,
            new Filter[TypedPath]() {
              override def accept(typedPath: TypedPath): Boolean =
                !typedPath.isDirectory || directoryRegistry.accept(typedPath.getPath)
            }
          )
          .iterator()
        while (it.hasNext) result = files.add(it.next()) || result
      } catch {
        case e: NoSuchFileException => files.remove(path)

        case e: IOException => e.printStackTrace()

      }
    } while (!Thread.currentThread().isInterrupted && result);
  }
// }
// }

  /**
   * Similar to register, but tracks all of the new files found in the directory. It polls the
   * directory until the contents stop changing to ensure that a callback is fired for each path in
   * the newly created directory (up to the maxDepth). The assumption is that once the callback is
   * fired for the path, it is safe to assume that no event for a new file in the directory is
   * missed. Without the polling, it would be possible that a new file was created in the directory
   * before we registered it with the watch service. If this happened, then no callback would be
   * invoked for that file.
   *
   * @param typedPath The newly created directory to add
   * @param newFiles The set of files that are found for the newly created directory
   */
  private def add(typedPath: TypedPath, newFiles: Set[TypedPath]): Unit = {
    try {
      if (directoryRegistry.maxDepthFor(typedPath.getPath) >= 0) {
        val dir: CachedDirectoryImpl[WatchedDirectory] = getRoot(typedPath.getPath.getRoot)
        if (dir != null) {
          update(dir, typedPath)
        }
      }
      maybePoll(typedPath, newFiles)
    } catch {
      case e: IOException => {}

    }
  }

  private def getRoot(root: Path): CachedDirectoryImpl[WatchedDirectory] = {
    var result: CachedDirectoryImpl[WatchedDirectory] =
      rootDirectories.get(root)
    if (result == null) {
      try {
        result = new CachedDirectoryImpl(
          root,
          root,
          converter,
          java.lang.Integer.MAX_VALUE,
          new Filter[TypedPath]() {
            override def accept(quickFile: TypedPath): Boolean =
              quickFile.isDirectory && directoryRegistry.accept(quickFile.getPath)
          },
          FileTreeViews.getDefault(false)
        ).init()
        rootDirectories.put(root, result)
      } catch {
        case e: IOException => {}

      }
    }
    result
  }

  private def registerImpl(path: Path, maxDepth: Int): Boolean = {
    val existingMaxDepth: Int = directoryRegistry.maxDepthFor(path)
    val result: Boolean = existingMaxDepth < maxDepth
    val typedPath: TypedPath = TypedPaths.get(path)
    val realPath: Path = typedPath.toRealPath()
    if (result && !managed) {
      directoryRegistry.addDirectory(typedPath.getPath, maxDepth)
    } else if (typedPath.getPath != realPath) {
      /*
       * Note that watchedDir is not null, which means that this typedPath has been
       * registered with a different alias.
       */

      throw new FileSystemLoopException(typedPath.toString)
    }
    val dir: CachedDirectoryImpl[WatchedDirectory] = getRoot(realPath.getRoot)
    if (dir != null) {
      val directories: List[Entry[WatchedDirectory]] =
        dir.listEntries(typedPath.getPath, -1, AllPass)
      if (result || directories.isEmpty || !isValid(directories.get(0).getValue)) {
        val toUpdate: Path = typedPath.getPath
        if (toUpdate != null) update(dir, typedPath)
      }
    }
    result
  }

  private def update(dir: CachedDirectoryImpl[WatchedDirectory], typedPath: TypedPath): Unit = {
    dir.update(typedPath).observe(updateCacheObserver)
  }

  private def close(either: com.swoval.functional.Either[IOException, WatchedDirectory]): Unit = {
    if (either.isRight) either.get.close()
  }

  private def isValid(
      either: com.swoval.functional.Either[IOException, WatchedDirectory]): Boolean =
    either.isRight && either.get.isValid

  override def addObserver(observer: Observer[Event]): Int = 0

  override def removeObserver(handle: Int): Unit = {}

}
