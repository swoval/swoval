// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.functional.Filters.AllPass
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.files.PathWatchers.Event.Kind
import com.swoval.functional.Either
import com.swoval.functional.Filter
import com.swoval.logging.Logger
import com.swoval.runtime.Platform
import java.io.IOException
import java.nio.file.Path
import java.util.Iterator

class SymlinkFollowingPathWatcher(
    private val pathWatcher: PathWatcher[PathWatchers.Event],
    directoryRegistry: DirectoryRegistry,
    logger: Logger
) extends PathWatcher[PathWatchers.Event] {

  private val symlinkWatcher: SymlinkWatcher = new SymlinkWatcher(
    if (Platform.isMac)
      new ApplePathWatcher(new DirectoryRegistryImpl(), logger)
    else PlatformWatcher.make(false, new DirectoryRegistryImpl(), logger),
    logger
  )

  private val observers: Observers[PathWatchers.Event] = new Observers()

  private val pathWatcherDirectoryRegistry: DirectoryRegistry =
    directoryRegistry

  pathWatcher.addObserver(new Observer[Event]() {
    override def onError(t: Throwable): Unit = {
      observers.onError(t)
    }

    override def onNext(event: Event): Unit = {
      val typedPath: TypedPath = event.getTypedPath
      if (typedPath.exists() && typedPath.isSymbolicLink) {
        try {
          val maxDepth: Int = directoryRegistry.maxDepthFor(typedPath.getPath)
          symlinkWatcher.addSymlink(typedPath.getPath, maxDepth)
          if (typedPath.isDirectory) {
            handleNewDirectory(typedPath.getPath, maxDepth, true)
          }
        } catch {
          case e: IOException => observers.onError(e)

        }
      } else if (!typedPath.exists()) {
        symlinkWatcher.remove(typedPath.getPath)
      }
      observers.onNext(event)
    }
  })

  symlinkWatcher.addObserver(new Observer[Event]() {
    override def onError(t: Throwable): Unit = {
      observers.onError(t)
    }

    override def onNext(event: Event): Unit = {
      observers.onNext(event)
    }
  })

  private def handleNewDirectory(path: Path, maxDepth: Int, trigger: Boolean): Unit = {
    val it: Iterator[TypedPath] =
      FileTreeViews.list(path, maxDepth, AllPass).iterator()
    while (it.hasNext) {
      val tp: TypedPath = it.next()
      if (tp.isSymbolicLink) {
        val p: Path = tp.getPath
        symlinkWatcher.addSymlink(p, pathWatcherDirectoryRegistry.maxDepthFor(p))
      }
      if (trigger) {
        observers.onNext(new Event(tp, Kind.Create))
      }
    }
  }

  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] = {
    val absolutePath: Path =
      if (path.isAbsolute) path else path.toAbsolutePath()
    val pathWatcherResult: Either[IOException, Boolean] =
      pathWatcher.register(absolutePath, maxDepth)
    var listResult: Either[IOException, Boolean] = pathWatcherResult
    if (pathWatcherResult.isRight) {
      try {
        handleNewDirectory(absolutePath, maxDepth, false)
        listResult = Either.right(true)
      } catch {
        case e: IOException => listResult = Either.left(e)

      }
    }
    listResult
  }

  override def unregister(path: Path): Unit = {
    val absolutePath: Path =
      if (path.isAbsolute) path else path.toAbsolutePath()
    try {
      val it: Iterator[TypedPath] = FileTreeViews
        .list(
          absolutePath,
          pathWatcherDirectoryRegistry.maxDepthFor(absolutePath),
          new Filter[TypedPath]() {
            override def accept(typedPath: TypedPath): Boolean =
              typedPath.isSymbolicLink
          }
        )
        .iterator()
      while (it.hasNext) symlinkWatcher.remove(it.next().getPath)
    } catch {
      case e: IOException => {}

    }
    pathWatcher.unregister(absolutePath)
  }

  override def close(): Unit = {
    pathWatcher.close()
    symlinkWatcher.close()
  }

  override def addObserver(observer: Observer[_ >: PathWatchers.Event]): Int =
    observers.addObserver(observer)

  override def removeObserver(handle: Int): Unit = {
    observers.removeObserver(handle)
  }

}
