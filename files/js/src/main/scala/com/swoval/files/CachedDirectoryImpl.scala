// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import java.io.IOException
import java.nio.file.Path
import java.util.{ ArrayList, Collection, HashMap, Iterator, List, Map }
import java.util.concurrent.atomic.AtomicReference

import com.swoval.files.CachedDirectoryImpl._
import com.swoval.files.DataViews.{ Converter, Entry }
import com.swoval.files.FileTreeViews.Updates
import com.swoval.functional.Either.leftProjection
import com.swoval.functional.{ Either, Filter }
import com.swoval.functional.Filters.AllPass

import scala.beans.BeanProperty

object CachedDirectoryImpl {

  /**
   * Returns the name components of a path in an array.
   *
   * @param path The path from which we extract the parts.
   * @return Empty array if path is an empty relative path, otherwise return the name parts.
   */
  private def parts(path: Path): List[Path] = {
    val it: Iterator[Path] = path.iterator()
    val result: List[Path] = new ArrayList[Path]()
    while (it.hasNext) result.add(it.next())
    result
  }

}

/**
 * Provides a mutable in-memory cache of files and subdirectories with basic CRUD functionality. The
 * CachedDirectory can be fully recursive as the subdirectories are themselves stored as recursive
 * (when the CachedDirectory is initialized without the recursive toggle, the subdirectories are
 * stored as [[Entry]] instances. The primary use case is the implementation of [[FileCache]] and [[NioPathWatcher]]. Directly handling CachedDirectory instances is discouraged
 * because it is inherently mutable so it's better to let the FileCache manage it and query the
 * cache rather than CachedDirectory directly.
 *
 * <p>The CachedDirectory should cache all of the files and subdirectories up the maximum depth. A
 * maximum depth of zero means that the CachedDirectory should cache the subdirectories, but not
 * traverse them. A depth {@code < 0} means that it should not cache any files or subdirectories
 * within the directory. In the event that a loop is created by symlinks, the CachedDirectory will
 * include the symlink that completes the loop, but will not descend further (inducing a loop).
 *
 * @tparam T the cache value type.
 */
class CachedDirectoryImpl[T <: AnyRef](@BeanProperty val path: Path,
                                       private val realPath: Path,
                                       private val converter: Converter[T],
                                       private val depth: Int,
                                       filter: Filter[_ >: TypedPath],
                                       private val fileTreeView: FileTreeView)
    extends CachedDirectory[T] {

  private val _cacheEntry: AtomicReference[Entry[T]] = new AtomicReference(null)

  private val lock: AnyRef = new AnyRef()

  private val subdirectories: Map[Path, CachedDirectoryImpl[T]] = new HashMap()

  private val files: Map[Path, Entry[T]] = new HashMap()

  private val pathFilter: Filter[_ >: TypedPath] = filter

  def getMaxDepth(): Int = depth

  override def list(maxDepth: Int, filter: Filter[_ >: TypedPath]): List[TypedPath] =
    list(getPath, maxDepth, filter)

  override def list(path: Path, maxDepth: Int, filter: Filter[_ >: TypedPath]): List[TypedPath] = {
    val findResult: Either[Entry[T], CachedDirectoryImpl[T]] = find(path)
    if (findResult != null) {
      if (findResult.isRight) {
        val result: List[TypedPath] = new ArrayList[TypedPath]()
        findResult.get.listImpl(maxDepth, filter, result)
        result
      } else {
        val entry: Entry[T] = leftProjection(findResult).getValue
        val result: List[TypedPath] = new ArrayList[TypedPath]()
        if (entry != null && filter.accept(entry)) result.add(entry)
        result
      }
    } else {
      new ArrayList()
    }
  }

  override def listEntries(path: Path,
                           maxDepth: Int,
                           filter: Filter[_ >: Entry[T]]): List[Entry[T]] = {
    val findResult: Either[Entry[T], CachedDirectoryImpl[T]] = find(path)
    if (findResult != null) {
      if (findResult.isRight) {
        val result: List[Entry[T]] = new ArrayList[Entry[T]]()
        findResult.get.listImpl(maxDepth, filter, result)
        result
      } else {
        val entry: Entry[T] = leftProjection(findResult).getValue
        val result: List[Entry[T]] = new ArrayList[Entry[T]]()
        if (entry != null && filter.accept(entry)) result.add(entry)
        result
      }
    } else {
      new ArrayList()
    }
  }

  override def listEntries(maxDepth: Int, filter: Filter[_ >: Entry[T]]): List[Entry[T]] =
    listEntries(getPath, maxDepth, filter)

  override def getEntry(): Entry[T] = _cacheEntry.get

  override def close(): Unit = {
    this.lock.synchronized {
      val it: Iterator[CachedDirectoryImpl[T]] =
        subdirectories.values.iterator()
      while (it.hasNext) it.next().close()
      subdirectories.clear()
      files.clear()
    }
  }

  val typedPath: TypedPath = TypedPaths.get(realPath)

  this._cacheEntry.set(Entries.get(TypedPaths.getDelegate(path, typedPath), converter, typedPath))

  /**
   * Updates the CachedDirectory entry for a particular typed path.
   *
   * @param typedPath the path to update
   * @return a list of updates for the path. When the path is new, the updates have the
   *     oldCachedPath field set to null and will contain all of the children of the new path when
   *     it is a directory. For an existing path, the List contains a single Updates that contains
   *     the previous and new [[Entry]].
   *     traversing the directory.
   */
  def update(typedPath: TypedPath): Updates[T] =
    if (pathFilter.accept(typedPath))
      updateImpl(if (typedPath.getPath == this.path) new ArrayList[Path]()
                 else parts(this.path.relativize(typedPath.getPath)),
                 typedPath)
    else new Updates[T]()

  /**
   * Remove a path from the directory.
   *
   * @param path the path to remove
   * @return a List containing the Entry instances for the removed path. The result also contains
   *     the cache entries for any children of the path when the path is a non-empty directory.
   */
  def remove(path: Path): List[Entry[T]] =
    if (path.isAbsolute && path.startsWith(this.path)) {
      removeImpl(parts(this.path.relativize(path)))
    } else {
      new ArrayList()
    }

  override def toString(): String =
    "CachedDirectory(" + path + ", maxDepth = " + depth +
      ")"

  private def subdirectoryDepth(): Int =
    if (depth == java.lang.Integer.MAX_VALUE) depth
    else if (depth > 0) depth - 1
    else 0

  private def addDirectory(currentDir: CachedDirectoryImpl[T],
                           path: Path,
                           updates: Updates[T]): Unit = {
    val dir: CachedDirectoryImpl[T] =
      new CachedDirectoryImpl(path,
                              path,
                              converter,
                              currentDir.subdirectoryDepth(),
                              pathFilter,
                              fileTreeView).init()
    val oldEntries: Map[Path, Entry[T]] = new HashMap[Path, Entry[T]]()
    val previous: CachedDirectoryImpl[T] =
      currentDir.subdirectories.put(path.getFileName, dir)
    if (previous != null) {
      oldEntries.put(previous.realPath, previous.getEntry)
      val entryIterator: Iterator[Entry[T]] =
        previous.listEntries(java.lang.Integer.MAX_VALUE, AllPass).iterator()
      while (entryIterator.hasNext) {
        val entry: Entry[T] = entryIterator.next()
        oldEntries.put(entry.getPath, entry)
      }
    }
    val newEntries: Map[Path, Entry[T]] = new HashMap[Path, Entry[T]]()
    newEntries.put(dir.realPath, dir.getEntry)
    val it: Iterator[Entry[T]] =
      dir.listEntries(java.lang.Integer.MAX_VALUE, AllPass).iterator()
    while (it.hasNext) {
      val entry: Entry[T] = it.next()
      newEntries.put(entry.getPath, entry)
    }
    MapOps.diffDirectoryEntries(oldEntries, newEntries, updates)
  }

  private def isLoop(path: Path, realPath: Path): Boolean =
    path.startsWith(realPath) && path != realPath

  private def updateImpl(parts: List[Path], typedPath: TypedPath): Updates[T] = {
    val result: Updates[T] = new Updates[T]()
    if (!parts.isEmpty) {
      val it: Iterator[Path] = parts.iterator()
      var currentDir: CachedDirectoryImpl[T] = this
      while (it.hasNext && currentDir != null && currentDir.depth >= 0) {
        val p: Path = it.next()
        if (p.toString.isEmpty) result
        val resolved: Path = currentDir.path.resolve(p)
        val realPath: Path = typedPath.getPath
        if (!it.hasNext) {
// We will always return from this block
          currentDir.lock.synchronized {
            val isDirectory: Boolean = typedPath.isDirectory
            if (!isDirectory || currentDir.depth <= 0 || isLoop(resolved, realPath)) {
              val previousCachedDirectoryImpl: CachedDirectoryImpl[T] =
                if (isDirectory) currentDir.subdirectories.get(p) else null
              val oldEntry: Entry[T] =
                if (previousCachedDirectoryImpl != null)
                  previousCachedDirectoryImpl.getEntry
                else currentDir.files.get(p)
              val newEntry: Entry[T] =
                Entries.get(TypedPaths.getDelegate(p, typedPath),
                            converter,
                            TypedPaths.getDelegate(resolved, typedPath))
              if (isDirectory) {
                currentDir.subdirectories.put(p,
                                              new CachedDirectoryImpl(resolved,
                                                                      realPath,
                                                                      converter,
                                                                      -1,
                                                                      pathFilter,
                                                                      fileTreeView))
              } else {
                currentDir.files.put(p, newEntry)
              }
              val oldResolvedEntry: Entry[T] =
                if (oldEntry == null) null
                else Entries.resolve(currentDir.path, oldEntry)
              if (oldResolvedEntry == null) {
                result.onCreate(Entries.resolve(currentDir.path, newEntry))
              } else {
                result.onUpdate(oldResolvedEntry, Entries.resolve(currentDir.path, newEntry))
              }
              result
            } else {
              addDirectory(currentDir, resolved, result)
              result
            }
          }
        } else {
          currentDir.lock.synchronized {
            val dir: CachedDirectoryImpl[T] = currentDir.subdirectories.get(p)
            if (dir == null && currentDir.depth > 0) {
              addDirectory(currentDir, currentDir.path.resolve(p), result)
            }
            currentDir = dir
          }
        }
      }
    } else if (typedPath.isDirectory) {
      val oldEntries: List[Entry[T]] = listEntries(getMaxDepth, AllPass)
      init()
      val newEntries: List[Entry[T]] = listEntries(getMaxDepth, AllPass)
      MapOps.diffDirectoryEntries(oldEntries, newEntries, result)
    } else {
      val oldEntry: Entry[T] = getEntry
      val tp: TypedPath = TypedPaths.getDelegate(realPath, typedPath)
      val newEntry: Entry[T] = Entries.get(tp, converter, tp)
      _cacheEntry.set(newEntry)
      result.onUpdate(oldEntry, getEntry)
    }
    result
  }

  private def findImpl(parts: List[Path]): Either[Entry[T], CachedDirectoryImpl[T]] = {
    val it: Iterator[Path] = parts.iterator()
    var currentDir: CachedDirectoryImpl[T] = this
    var result: Either[Entry[T], CachedDirectoryImpl[T]] = null
    while (it.hasNext && currentDir != null && result == null) {
      val p: Path = it.next()
      if (!it.hasNext) {
        currentDir.lock.synchronized {
          val subdir: CachedDirectoryImpl[T] = currentDir.subdirectories.get(p)
          if (subdir != null) {
            result = Either.right(subdir)
          } else {
            val entry: Entry[T] = currentDir.files.get(p)
            if (entry != null)
              result = Either.left(Entries.resolve(currentDir.path, entry))
          }
        }
      } else {
        currentDir.lock.synchronized {
          currentDir = currentDir.subdirectories.get(p)
        }
      }
    }
    result
  }

  private def find(path: Path): Either[Entry[T], CachedDirectoryImpl[T]] =
    if (path == this.path) {
      Either.right(this)
    } else if (!path.isAbsolute) {
      findImpl(parts(path))
    } else if (path.startsWith(this.path)) {
      findImpl(parts(this.path.relativize(path)))
    } else {
      null
    }

  private def listImpl[R](maxDepth: Int, filter: Filter[_ >: R], result: List[_ >: R]): Unit = {
    if (this.depth < 0 || maxDepth < 0) {
      result.add(this.getEntry.asInstanceOf[R])
    } else {
      var files: Collection[Entry[T]] = null
      var subdirectories: Collection[CachedDirectoryImpl[T]] = null
      this.lock.synchronized {
        files = new ArrayList(this.files.values)
        subdirectories = new ArrayList(this.subdirectories.values)
      }
      val filesIterator: Iterator[Entry[T]] = files.iterator()
      while (filesIterator.hasNext) {
        val entry: Entry[T] = filesIterator.next()
        val resolved: Entry[T] = Entries.resolve(getPath, entry)
        if (filter.accept(resolved.asInstanceOf[R]))
          result.add(resolved.asInstanceOf[R])
      }
      val subdirIterator: Iterator[CachedDirectoryImpl[T]] =
        subdirectories.iterator()
      while (subdirIterator.hasNext) {
        val subdir: CachedDirectoryImpl[T] = subdirIterator.next()
        val entry: Entry[T] = subdir.getEntry
        val resolved: Entry[T] = Entries.resolve(getPath, entry)
        if (filter.accept(resolved.asInstanceOf[R]))
          result.add(resolved.asInstanceOf[R])
        if (maxDepth > 0) subdir.listImpl(maxDepth - 1, filter, result)
      }
    }
  }

  private def removeImpl(parts: List[Path]): List[Entry[T]] = {
    val result: List[Entry[T]] = new ArrayList[Entry[T]]()
    val it: Iterator[Path] = parts.iterator()
    var currentDir: CachedDirectoryImpl[T] = this
    while (it.hasNext && currentDir != null) {
      val p: Path = it.next()
      if (!it.hasNext) {
        currentDir.lock.synchronized {
          val entry: Entry[T] = currentDir.files.remove(p)
          if (entry != null) {
            result.add(Entries.resolve(currentDir.path, entry))
          } else {
            val dir: CachedDirectoryImpl[T] =
              currentDir.subdirectories.remove(p)
            if (dir != null) {
              result.addAll(dir.listEntries(java.lang.Integer.MAX_VALUE, AllPass))
              result.add(dir.getEntry)
            }
          }
        }
      } else {
        currentDir.lock.synchronized {
          currentDir = currentDir.subdirectories.get(p)
        }
      }
    }
    result
  }

  private def toRealPath(path: Path): Path =
    try path.toRealPath()
    catch {
      case e: IOException => path

    }

  def init(): CachedDirectoryImpl[T] = {
    subdirectories.clear()
    files.clear()
    if (depth >= 0) {
      lock.synchronized {
        val it: Iterator[TypedPath] =
          fileTreeView.list(path, 0, pathFilter).iterator()
        while (it.hasNext) {
          val file: TypedPath = it.next()
          if (pathFilter.accept(file)) {
            val path: Path = file.getPath
            val key: Path = this.path.relativize(path).getFileName
            if (file.isDirectory) {
              if (depth > 0) {
                val realPath: Path = toRealPath(path)
                if (!file.isSymbolicLink || !isLoop(path, realPath)) {
                  val dir: CachedDirectoryImpl[T] =
                    new CachedDirectoryImpl[T](path,
                                               realPath,
                                               converter,
                                               subdirectoryDepth(),
                                               pathFilter,
                                               fileTreeView)
                  subdirectories.put(key, dir)
                  try dir.init()
                  catch {
                    case e: IOException => {}

                  }
                } else {
                  subdirectories.put(key,
                                     new CachedDirectoryImpl(path,
                                                             realPath,
                                                             converter,
                                                             -1,
                                                             pathFilter,
                                                             fileTreeView))
                }
              } else {
                files.put(key, Entries.get(TypedPaths.getDelegate(key, file), converter, file))
              }
            } else {
              files.put(key, Entries.get(TypedPaths.getDelegate(key, file), converter, file))
            }
          }
        }
      }
    }
    this
  }

}
