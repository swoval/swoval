// Do not edit this file manually. It is autogenerated.

package com.swoval.functional

import Either._
import scala.beans.{ BeanProperty, BooleanBeanProperty }

object Either {

  /**
   * Returns the Left projection for the provided Either or throws an exception if the Either is
   * actually an instance of [[com.swoval.functional.Either.Right]].
   *
   * @param either the either, assumed to be an instance of left, that will
   * @tparam L the left type of the either.
   * @tparam R the right type of the either.
   * @return a Left projection.
   */
  def leftProjection[L, R](either: Either[L, R]): Left[L, R] =
    if (either.isLeft) either.asInstanceOf[Left[L, R]]
    else throw new NotLeftException()

  /**
   * Returns the Right projection for the provided Either or throws an exception if the Either is
   * actually an instance of [[com.swoval.functional.Either.Left]].
   *
   * @param either the either, assumed to be an instance of left, that will
   * @tparam L the left type of the either.
   * @tparam R the right type of the either.
   * @return a Right projection.
   */
  def rightProjection[L, R](either: Either[L, R]): Right[L, R] =
    if (either.isRight) either.asInstanceOf[Right[L, R]]
    else throw new NotRightException()

  /**
   * Get the right projected value of the either or a provided default value.
   *
   * @param either the either from which the method extracts the result if it is a [[    com.swoval.functional.Either.Right]].
   * @param t the default value
   * @tparam T the default type
   * @return the wrapped value if this is a right projection, otherwise the default
   */
  def getOrElse[T](either: Either[_, _ <: T], t: T): T =
    if (either.isRight) either.get else t

  /**
   * Returns a left projected either.
   *
   * @param value the value to wrap
   * @tparam L the type of the left parameter of the result
   * @tparam R the type of the right parameter of the result
   * @tparam T a refinement type that allows us to wrap subtypes of L
   * @return A left projected either
   */
  def left[L, R, T <: L](value: T): Either[L, R] =
    new Left(value.asInstanceOf[L])

  /**
   * Returns a right projected either.
   *
   * @param value the value to wrap
   * @tparam L the type of the left parameter of the result
   * @tparam R the type of the right parameter of the result
   * @tparam T a refinement type that allows us to wrap subtypes of R
   * @return a right projected either.
   */
  def right[L, R, T <: R](value: T): Either[L, R] =
    new Right(value.asInstanceOf[R])

  /**
   * An error that is thrown if an attempt is made to project an Either to [[com.swoval.functional.Either.Left]] when the object is actually an instance of [[com.swoval.functional.Either.Right]].
   */
  class NotLeftException extends RuntimeException

  /**
   * An error that is thrown if an attempt is made to project an Either to [[com.swoval.functional.Either.Right]] when the object is actually an instance of [[com.swoval.functional.Either.Left]].
   */
  class NotRightException extends RuntimeException

  /**
   * A left projected [[com.swoval.functional.Either]].
   *
   * @tparam L the left type
   * @tparam R the right type
   */
  class Left[L, R](@BeanProperty val value: L) extends Either[L, R] {

    override def isLeft(): Boolean = true

    override def isRight(): Boolean = false

    override def toString(): String = "Left(" + value + ")"

    override def equals(other: Any): Boolean = other match {
      case other: com.swoval.functional.Either.Left[_, _] =>
        this.value == other.getValue
      case _ => false

    }

    override def hashCode(): Int = value.hashCode

  }

  /**
   * A right projected [[com.swoval.functional.Either]].
   *
   * @tparam L the left type
   * @tparam R the right type
   */
  class Right[L, R](@BeanProperty val value: R) extends Either[L, R] {

    override def isLeft(): Boolean = false

    override def isRight(): Boolean = true

    override def toString(): String = "Right(" + value + ")"

    override def equals(other: Any): Boolean = other match {
      case other: com.swoval.functional.Either.Right[_, _] =>
        this.value == other.getValue
      case _ => false

    }

    override def hashCode(): Int = value.hashCode

  }

}

/**
 * Represents a value that can be one of two types. Inspired by [[https://www.scala-lang.org/api/current/scala/util/Either.html Either]],
 * it is right biased, but does not define all of the combinators that the scala version does.
 *
 * @tparam L The left value
 * @tparam R The right value
 */
abstract class Either[+L, +R] private () {

  /**
   * Check whether this is a Left projection.
   *
   * @return true if this is a Reft projection
   */
  def isLeft(): Boolean

  /**
   * Check whether this is a Right projection.
   *
   * @return true if this is a Right projection
   */
  def isRight(): Boolean

  /**
   * Get the right projected value of the either. This is unsafe to call without checking whether
   * the value is a right first.
   *
   * @return the wrapped value if is a right projection
   */
  def get(): R =
    if (isRight) rightProjection(this).getValue
    else throw new NotRightException()

  override def hashCode(): Int

  override def equals(other: Any): Boolean

}
