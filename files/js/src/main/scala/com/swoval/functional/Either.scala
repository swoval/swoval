// Do not edit this file manually. It is autogenerated.

package com.swoval.functional

import Either._
import scala.beans.{ BeanProperty, BooleanBeanProperty }

object Either {

  /**
   * Returns the Left projection for the provided Either or throws an exception if the Either is
   * actually an instance of [[com.swoval.functional.Either.Right]].
   *
   * @param either the either, assumed to be an instance of left, that will
   * @tparam L the left type of the either.
   * @tparam R the right type of the either.
   * @return a Left projection.
   */
  def leftProjection[L, R](either: Either[L, R]): Left[L, R] =
    if (either.isLeft) either.asInstanceOf[Left[L, R]]
    else throw new NotLeftException()

  /**
   * Returns the Right projection for the provided Either or throws an exception if the Either is
   * actually an instance of [[com.swoval.functional.Either.Left]].
   *
   * @param either the either, assumed to be an instance of left, that will
   * @tparam L the left type of the either.
   * @tparam R the right type of the either.
   * @return a Right projection.
   */
  def rightProjection[L, R](either: Either[L, R]): Right[L, R] =
    if (either.isRight) either.asInstanceOf[Right[L, R]]
    else throw new NotRightException()

  /**
   * Get the right projected value of the either or a provided default value.
   *
   * @param either the either from which the method extracts the result if it is a [[    com.swoval.functional.Either.Right]].
   * @param t the default value
   * @tparam T the default type
   * @return the wrapped value if this is a right projection, otherwise the default
   */
  def getOrElse[T](either: Either[_, _ <: T], t: T): T =
    if (either.isRight) either.get else t

  /**
   * Returns a left projected either.
   *
   * @param value the value to wrap
   * @tparam L the type of the left parameter of the result
   * @tparam R the type of the right parameter of the result
   * @tparam T a refinement type that allows us to wrap subtypes of L
   * @return A left projected either
   */
  def left[L, R, T <: L](value: T): Either[L, R] =
    new Left(value.asInstanceOf[L])

  /**
   * Returns a right projected either.
   *
   * @param value the value to wrap
   * @tparam L the type of the left parameter of the result
   * @tparam R the type of the right parameter of the result
   * @tparam T a refinement type that allows us to wrap subtypes of R
   * @return a right projected either.
   */
  def right[L, R, T <: R](value: T): Either[L, R] =
    new Right(value.asInstanceOf[R])

  /**
   * An error that is thrown if an attempt is made to project an Either to [[com.swoval.functional.Either.Left]] when the object is actually an instance of [[com.swoval.functional.Either.Right]].
   */
  class NotLeftException extends RuntimeException

  /**
   * An error that is thrown if an attempt is made to project an Either to [[com.swoval.functional.Either.Right]] when the object is actually an instance of [[com.swoval.functional.Either.Left]].
   */
  class NotRightException extends RuntimeException

  /**
   * A left projected [[com.swoval.functional.Either]].
   *
   * @tparam L the left type
   * @tparam R the right type
   */
  class Left[L, R](@BeanProperty val value: L) extends Either[L, R] {

    override def isLeft(): Boolean = true

    override def isRight(): Boolean = false

    override def toString(): String = "Left(" + value + ")"

    override def equals(other: Any): Boolean = other match {
      case other: com.swoval.functional.Either.Left[_, _] =>
        this.value == other.getValue
      case _ => false

    }

    override def hashCode(): Int = value.hashCode

  }

  /**
   * A right projected [[com.swoval.functional.Either]].
   *
   * @tparam L the left type
   * @tparam R the right type
   */
  class Right[L, R](@BeanProperty val value: R) extends Either[L, R] {

    override def isLeft(): Boolean = false

    override def isRight(): Boolean = true

    override def toString(): String = "Right(" + value + ")"

    override def equals(other: Any): Boolean = other match {
      case other: com.swoval.functional.Either.Right[_, _] =>
        this.value == other.getValue
      case _ => false

    }

    override def hashCode(): Int = value.hashCode

  }

}

/**
 * Represents a value that can be one of two types. Inspired by [[https://www.scala-lang.org/api/current/scala/util/Either.html Either]],
 * it is right biased, but does not define all of the combinators that the scala version does.
 *
 * @tparam L The left value
 * @tparam R The right value
 */
abstract class Either[+L, +R] private () {

  /**
   * Check whether this is a Left projection.
   *
   * @return true if this is a Reft projection
   */
  def isLeft(): Boolean

  /**
   * Check whether this is a Right projection.
   *
   * @return true if this is a Right projection
   */
  def isRight(): Boolean

  /**
   * Get the right projected value of the either. This is unsafe to call without checking whether
   * the value is a right first.
   *
   * @return the wrapped value if is a right projection
   */
  def get(): R =
    if (isRight) rightProjection(this).getValue
    else throw new NotRightException()

  override def hashCode(): Int

  override def equals(other: Any): Boolean

  /**
   * Casts an either to a more specific left type. If the cast cannot be made, return a default
   * value instead.
   *
   * @param clazz the left type to which we downcast
   * @param defaultValue the value to return if the cast fails
   * @tparam L the original left type
   * @tparam R the right type
   * @tparam T the downcasted left type
   * @return the original either with the left type downcasted to T.
   */
  def castLeft[L, R, T <: L](clazz: Class[T], defaultValue: R): Either[T, R] =
    if (isRight) {
      this.asInstanceOf[Either[T, R]]
    } else if (clazz.isAssignableFrom(leftProjection(this).getValue.getClass)) {
      this.asInstanceOf[Either[T, R]]
    } else {
      Either.right(defaultValue)
    }

  /**
   * Casts an either to a more specific right type.
   *
   * @param clazz The right type to which we downcast
   * @tparam L The original left type
   * @tparam R The right type
   * @tparam T The downcasted right type
   * @return The original either with the right type downcasted to T.
   */
  def castRight[L, R, T <: R](clazz: Class[T]): Either[L, T] =
    if (this.isLeft) this.asInstanceOf[Either[L, T]]
    else if (clazz.isAssignableFrom(get.getClass))
      this.asInstanceOf[Either[L, T]]
    else
      throw new ClassCastException(rightProjection(this) + " is not an instance of " + clazz)

}
